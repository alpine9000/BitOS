
;; Function main (main, funcdef_no=0, decl_uid=1459, cgraph_uid=0, symbol_order=3) (executed once)

Processing loop 1
Creating dr for b[i_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {0, +, 1}_1
Creating dr for a[i_34]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {0, +, 1}_1
(compute_affine_dependence
  stmt_a: b[i_34] = i_34;
  stmt_b: a[i_34] = i_34;
) -> no dependence
(compute_affine_dependence
  stmt_a: b[i_34] = i_34;
  stmt_b: b[i_34] = i_34;
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: a[i_34] = i_34;
  stmt_b: a[i_34] = i_34;
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_34] = i_34;
#  ref: b[i_34];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_34] = i_34;
#  ref: a[i_34];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_34] = i_34;
#  ref: b[i_34];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_34] = i_34;
#  ref: b[i_34];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_34] = i_34;
#  ref: a[i_34];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_34] = i_34;
#  ref: a[i_34];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    a[i_34] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    b[i_34] (id 0, write)
      offset 0
      distance 0

Predictive commoning failed: no suitable chains
Processing loop 2
Creating dr for a[_11]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 12
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {3, +, 1}_2
Creating dr for b[i_13]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {2, +, 1}_2
Creating dr for b[_16]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {0, +, 1}_2
Creating dr for a[i_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {1, +, 1}_2
Creating dr for c[i_35]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &c
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: c
	Access function 0: {1, +, 1}_2
(compute_affine_dependence
  stmt_a: _12 = a[_11];
  stmt_b: _14 = b[i_13];
) -> no dependence
(compute_affine_dependence
  stmt_a: _12 = a[_11];
  stmt_b: _17 = b[_16];
) -> no dependence
(compute_affine_dependence
  stmt_a: _12 = a[_11];
  stmt_b: _18 = a[i_35];
(analyze_overlapping_iterations 
  (chrec_a = {3, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [2 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [2 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {3, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _12 = a[_11];
  stmt_b: c[i_35] = _20;
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = b[i_13];
  stmt_b: _17 = b[_16];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [2 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [2 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _14 = b[i_13];
  stmt_b: _18 = a[i_35];
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = b[i_13];
  stmt_b: c[i_35] = _20;
) -> no dependence
(compute_affine_dependence
  stmt_a: _17 = b[_16];
  stmt_b: _18 = a[i_35];
) -> no dependence
(compute_affine_dependence
  stmt_a: _17 = b[_16];
  stmt_b: c[i_35] = _20;
) -> no dependence
(compute_affine_dependence
  stmt_a: _18 = a[i_35];
  stmt_b: c[i_35] = _20;
) -> no dependence
(compute_affine_dependence
  stmt_a: _12 = a[_11];
  stmt_b: _12 = a[_11];
(analyze_overlapping_iterations 
  (chrec_a = {3, +, 1}_2)
  (chrec_b = {3, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _14 = b[i_13];
  stmt_b: _14 = b[i_13];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _17 = b[_16];
  stmt_b: _17 = b[_16];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _18 = a[i_35];
  stmt_b: _18 = a[i_35];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: c[i_35] = _20;
  stmt_b: c[i_35] = _20;
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {3, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 995
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 995
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 995
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 995
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _12 = a[_11];
#  ref: a[_11];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
  access_fn_A: {3, +, 1}_2
  access_fn_B: {3, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {2, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _17 = b[_16];
#  ref: b[_16];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {0, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = a[i_35];
#  ref: a[i_35];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {1, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_35] = _20;
#  ref: c[i_35];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {1, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    c[i_35] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    b[i_13] (id 0)
      offset 0
      distance 0
    b[_16] (id 1)
      offset 0
      distance 0

Component (invariant):
    a[_11] (id 0)
      offset 0
      distance 0
    a[i_35] (id 1)
      offset 0
      distance 0

Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Loads-only chain 0x1416326d0 (combined)
  max distance 2
  inits MEM[(int *)&b] MEM[(int *)&b + 4B]
  references:
    b[i_13] (id 0)
      offset 0
      distance 0
    b[_16] (id 1)
      offset 2
      distance 2

Loads-only chain 0x141632c60 (combined)
  max distance 2
  inits MEM[(int *)&a + 4B] MEM[(int *)&a + 8B]
  references:
    a[_11] (id 0)
      offset 0
      distance 0
    a[i_35] (id 1)
      offset 2
      distance 2

Combination chain 0x141632ce0
  max distance 2
  equal to 0x141632c60 * 0x1416326d0 in type int
  references:
    combination ref
      in statement _15 = _12 * _14;

      distance 0
    combination ref
      in statement _19 = _17 * _18;

      distance 2

Analyzing # of iterations of loop 2
  exit condition [996, + , 4294967295] != 0
  bounds on difference of bases: -996 ... -996
  result:
    # of iterations 996, bounded by 996
Unrolling 3 times.

Updating SSA:
creating PHI node in block #8 for .MEM_21
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #6
Updating SSA information for statement _11 = i_35 + 2;
Updating SSA information for statement _12 = a[_11];
Updating SSA information for statement i_13 = i_35 + 1;
Updating SSA information for statement _14 = b[i_13];
Updating SSA information for statement _15 = _12 * _14;
Updating SSA information for statement _16 = i_35 + -1;
Updating SSA information for statement _17 = b[_16];
Updating SSA information for statement _18 = a[i_35];
Updating SSA information for statement _19 = _17 * _18;
Updating SSA information for statement _20 = _15 - _19;
Updating SSA information for statement c[i_35] = _20;
Updating SSA information for statement ivtmp_33 = ivtmp_39 - 1;
Updating SSA information for statement if (ivtmp_33 != 0)
Registering new PHI nodes in block #7
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Updating SSA information for statement _22 = i_35 + 2;
Updating SSA information for statement _8 = a[_11];
Updating SSA information for statement i_5 = i_35 + 1;
Updating SSA information for statement _4 = b[i_13];
Updating SSA information for statement _3 = _12 * _14;
Updating SSA information for statement _2 = i_35 + -1;
Updating SSA information for statement _1 = b[_16];
Updating SSA information for statement _47 = a[i_35];
Updating SSA information for statement _46 = _17 * _18;
Updating SSA information for statement _45 = _15 - _19;
Updating SSA information for statement c[i_35] = _20;
Updating SSA information for statement ivtmp_43 = ivtmp_39 - 1;
Updating SSA information for statement if (ivtmp_33 != 0)
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _23 = c[i_36];
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Updating SSA information for statement return 0;
Registering new PHI nodes in block #10
Updating SSA information for statement abort ();

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_1 -> { _17 }
_2 -> { _16 }
_3 -> { _15 }
_4 -> { _14 }
i_5 -> { i_13 }
_8 -> { _12 }
_22 -> { _11 }
ivtmp_28 -> { ivtmp_39 }
.MEM_29 -> { .MEM_38 }
i_30 -> { i_35 }
.MEM_42 -> { .MEM_21 }
ivtmp_43 -> { ivtmp_33 }
.MEM_44 -> { .MEM_21 }
_45 -> { _20 }
_46 -> { _19 }
_47 -> { _18 }
Incremental SSA update started at block: 16
Number of blocks in CFG: 19
Number of blocks to update: 10 ( 53%)
Affected blocks: 6 7 8 9 10 13 14 15 17 18


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       8



Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement b[i_34] = i_34;
Updating SSA information for statement a[i_34] = i_34;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Updating SSA information for statement _54 = MEM[(int *)&a + 4B];
Updating SSA information for statement _55 = MEM[(int *)&b];
Updating SSA information for statement _57 = MEM[(int *)&a + 8B];
Updating SSA information for statement _58 = MEM[(int *)&b + 4B];
Registering new PHI nodes in block #6
Updating SSA information for statement _12 = a[_11];
Updating SSA information for statement _14 = b[i_13];
Updating SSA information for statement c[i_35] = _20;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #19
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Updating SSA information for statement _8 = a[_22];
Updating SSA information for statement _4 = b[i_5];
Updating SSA information for statement _1 = b[_2];
Updating SSA information for statement _47 = a[i_30];
Updating SSA information for statement c[i_30] = _45;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _23 = c[i_36];
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Updating SSA information for statement return 0;
Registering new PHI nodes in block #10
Updating SSA information for statement abort ();

Symbols to be put in SSA form
{ D.1490 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 21
Number of blocks to update: 19 ( 90%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19


Removing basic block 27
basic block 27, loop depth 0
 pred:      
 succ:       18


Removing basic block 28
basic block 28, loop depth 0
 pred:      
 succ:       18



Updating SSA:
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #6
Updating SSA information for statement _11 = i_35 + 2;
Updating SSA information for statement _12 = a[_11];
Updating SSA information for statement i_13 = i_35 + 1;
Updating SSA information for statement _14 = b[i_13];
Updating SSA information for statement _15 = _12 * _14;
Updating SSA information for statement D_lsm2.5_53 = _15;
Updating SSA information for statement _16 = i_35 + -1;
Updating SSA information for statement _19 = D_lsm0.3_51;
Updating SSA information for statement _20 = _15 - _19;
Updating SSA information for statement c[i_35] = _20;
Updating SSA information for statement ivtmp_33 = ivtmp_39 - 1;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #19
Registering new PHI nodes in block #21
Updating SSA information for statement _63 = i_35 + 2;
Updating SSA information for statement _64 = a[_11];
Updating SSA information for statement i_65 = i_35 + 1;
Updating SSA information for statement _66 = b[i_13];
Updating SSA information for statement _67 = _12 * _14;
Updating SSA information for statement D_lsm2.5_68 = _15;
Updating SSA information for statement _69 = i_35 + -1;
Updating SSA information for statement _70 = D_lsm0.3_51;
Updating SSA information for statement _71 = _15 - _19;
Updating SSA information for statement c[i_35] = _20;
Updating SSA information for statement ivtmp_73 = ivtmp_39 - 1;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #23
Registering new PHI nodes in block #24
Updating SSA information for statement _79 = i_35 + 2;
Updating SSA information for statement _80 = a[_11];
Updating SSA information for statement i_81 = i_35 + 1;
Updating SSA information for statement _82 = b[i_13];
Updating SSA information for statement _83 = _12 * _14;
Updating SSA information for statement D_lsm2.5_84 = _15;
Updating SSA information for statement _85 = i_35 + -1;
Updating SSA information for statement _86 = D_lsm0.3_51;
Updating SSA information for statement _87 = _15 - _19;
Updating SSA information for statement c[i_35] = _20;
Updating SSA information for statement ivtmp_89 = ivtmp_39 - 1;
Registering new PHI nodes in block #25
Registering new PHI nodes in block #26
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #10

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_17 -> { .MEM_38 }
i_18 -> { i_35 }
ivtmp_60 -> { ivtmp_39 }
D_lsm0.3_61 -> { D_lsm0.3_51 }
D_lsm1.4_62 -> { D_lsm1.4_52 }
_63 -> { _11 }
_64 -> { _12 }
i_65 -> { i_13 }
_66 -> { _14 }
_67 -> { _15 }
D_lsm2.5_68 -> { D_lsm2.5_53 }
_69 -> { _16 }
_70 -> { _19 }
_71 -> { _20 }
.MEM_72 -> { .MEM_21 }
ivtmp_73 -> { ivtmp_33 }
i_74 -> { i_35 }
.MEM_75 -> { .MEM_38 }
ivtmp_76 -> { ivtmp_39 }
D_lsm0.3_77 -> { D_lsm0.3_51 }
D_lsm1.4_78 -> { D_lsm1.4_52 }
_79 -> { _11 }
_80 -> { _12 }
i_81 -> { i_13 }
_82 -> { _14 }
_83 -> { _15 }
D_lsm2.5_84 -> { D_lsm2.5_53 }
_85 -> { _16 }
_86 -> { _19 }
_87 -> { _20 }
.MEM_88 -> { .MEM_21 }
ivtmp_89 -> { ivtmp_33 }
Incremental SSA update started at block: 16
Number of blocks in CFG: 29
Number of blocks to update: 8 ( 28%)
Affected blocks: 6 18 19 21 23 24 25 26


Processing loop 3
Creating dr for c[i_36]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &c
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: c
	Access function 0: {1, +, 1}_3
(compute_affine_dependence
  stmt_a: _23 = c[i_36];
  stmt_b: _23 = c[i_36];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_3)
  (chrec_b = {1, +, 1}_3)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 9 
#  stmt: _23 = c[i_36];
#  ref: c[i_36];
#  base_object: c;
#  Access function 0: {1, +, 1}_3
#)
#(Data Ref: 
#  bb: 9 
#  stmt: _23 = c[i_36];
#  ref: c[i_36];
#  base_object: c;
#  Access function 0: {1, +, 1}_3
#)
  access_fn_A: {1, +, 1}_3
  access_fn_B: {1, +, 1}_3

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (3 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    c[i_36] (id 0)
      offset 0
      distance 0

Predictive commoning failed: no suitable chains
Removing basic block 5
basic block 5, loop depth 0
 pred:      
 succ:       16


Merging blocks 6 and 7
Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       17


Removing basic block 19
basic block 19, loop depth 1
 pred:      
 succ:       21


Removing basic block 22
basic block 22, loop depth 1
 pred:      
 succ:       23


Removing basic block 23
basic block 23, loop depth 1
 pred:      
 succ:       24


Merging blocks 6 and 21
Merging blocks 6 and 24
Merging blocks 6 and 25
main ()
{
  int D_lsm2.5;
  int D_lsm1.4;
  int D_lsm0.3;
  int i;
  int _1;
  int _2;
  int _3;
  int _4;
  int _8;
  int _11;
  int _12;
  int _14;
  int _15;
  int _16;
  int _19;
  int _20;
  int _22;
  int _23;
  int _24;
  int _25;
  unsigned int ivtmp_28;
  unsigned int ivtmp_31;
  unsigned int ivtmp_32;
  unsigned int ivtmp_33;
  unsigned int ivtmp_39;
  unsigned int ivtmp_40;
  unsigned int ivtmp_41;
  unsigned int ivtmp_43;
  int _45;
  int _46;
  int _47;
  unsigned int ivtmp_50;
  int _54;
  int _55;
  int _56;
  int _57;
  int _58;
  int _59;
  int _63;
  int _64;
  int _66;
  int _67;
  int _69;
  int _70;
  int _71;
  unsigned int ivtmp_73;
  int _79;
  int _80;
  int _82;
  int _83;
  int _85;
  int _86;
  int _87;
  unsigned int ivtmp_89;
  unsigned int ivtmp_90;
  unsigned int ivtmp_91;

  <bb 2>:

  <bb 3>:
  # i_34 = PHI <i_10(4), 0(2)>
  # ivtmp_32 = PHI <ivtmp_31(4), 1000(2)>
  b[i_34] = i_34;
  a[i_34] = i_34;
  i_10 = i_34 + 1;
  ivtmp_31 = ivtmp_32 - 1;
  if (ivtmp_31 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:
  _54 = MEM[(int *)&a + 4B];
  _55 = MEM[(int *)&b];
  _56 = _54 * _55;
  _57 = MEM[(int *)&a + 8B];
  _58 = MEM[(int *)&b + 4B];
  _59 = _57 * _58;

  <bb 6>:
  # i_35 = PHI <1(5), i_81(7)>
  # ivtmp_39 = PHI <997(5), ivtmp_89(7)>
  # D_lsm0.3_51 = PHI <_56(5), D_lsm0.3_68(7)>
  # D_lsm1.4_52 = PHI <_59(5), D_lsm1.4_84(7)>
  # ivtmp_90 = PHI <996(5), ivtmp_91(7)>
  _11 = i_35 + 2;
  _12 = a[_11];
  i_13 = i_35 + 1;
  _14 = b[i_13];
  _15 = _12 * _14;
  D_lsm2.5_53 = _15;
  _16 = i_35 + -1;
  _19 = D_lsm0.3_51;
  _20 = _15 - _19;
  c[i_35] = _20;
  ivtmp_33 = ivtmp_39 - 1;
  _63 = i_13 + 2;
  _64 = a[_63];
  i_65 = i_13 + 1;
  _66 = b[i_65];
  _67 = _64 * _66;
  D_lsm0.3_68 = _67;
  _69 = i_13 + -1;
  _70 = D_lsm1.4_52;
  _71 = _67 - _70;
  c[i_13] = _71;
  ivtmp_73 = ivtmp_33 + 4294967295;
  _79 = i_65 + 2;
  _80 = a[_79];
  i_81 = i_65 + 1;
  _82 = b[i_81];
  _83 = _80 * _82;
  D_lsm1.4_84 = _83;
  _85 = i_65 + -1;
  _86 = D_lsm2.5_53;
  _87 = _83 - _86;
  c[i_65] = _87;
  ivtmp_89 = ivtmp_73 + 4294967295;
  ivtmp_91 = ivtmp_90 - 3;
  if (ivtmp_91 > 2)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  # i_48 = PHI <i_81(6)>
  # ivtmp_50 = PHI <ivtmp_89(6)>

  <bb 9>:
  # i_30 = PHI <i_48(8), i_5(10)>
  # ivtmp_28 = PHI <ivtmp_50(8), ivtmp_43(10)>
  _22 = i_30 + 2;
  _8 = a[_22];
  i_5 = i_30 + 1;
  _4 = b[i_5];
  _3 = _8 * _4;
  _2 = i_30 + -1;
  _1 = b[_2];
  _47 = a[i_30];
  _46 = _1 * _47;
  _45 = _3 - _46;
  c[i_30] = _45;
  ivtmp_43 = ivtmp_28 - 1;
  if (ivtmp_43 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 9>;

  <bb 11>:

  <bb 12>:
  # i_36 = PHI <1(11), i_26(15)>
  # ivtmp_41 = PHI <997(11), ivtmp_40(15)>
  _23 = c[i_36];
  _24 = i_36 * 4;
  _25 = _24 + 2;
  if (_23 != _25)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  abort ();

  <bb 14>:
  i_26 = i_36 + 1;
  ivtmp_40 = ivtmp_41 - 1;
  if (ivtmp_40 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  goto <bb 12>;

  <bb 16>:
  return 0;

}


