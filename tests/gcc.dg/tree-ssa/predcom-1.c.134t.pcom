
;; Function count_fib (count_fib, funcdef_no=0, decl_uid=1457, cgraph_uid=0, symbol_order=1)

Processing loop 1
Creating dr for fib[i_16]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for fib[pretmp_19]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for fib[pretmp_22]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {1, +, 1}_1
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: pretmp_20 = fib[pretmp_19];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [1 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [1 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [1 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [1 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  1 
  )
)
)
(compute_affine_dependence
  stmt_a: pretmp_20 = fib[pretmp_19];
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [1 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [1 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [1 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [1 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  1 
  )
)
)
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: fib[i_16] = _11;
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: pretmp_20 = fib[pretmp_19];
  stmt_b: pretmp_20 = fib[pretmp_19];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: pretmp_23 = fib[pretmp_22];
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [1 + 1 * x_1]
  last_conflict: 997
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 997
  (Subscript distance: 1 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   1 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [1 + 1 * x_1]
  last_conflict: 997
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 997
  (Subscript distance: 1 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   1 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {1, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    fib[i_16] (id 0, write)
      offset 0
      distance 0
    fib[pretmp_19] (id 1)
      offset 0
      distance 0
    fib[pretmp_22] (id 2)
      offset 0
      distance 0

Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Store-loads chain 0x101019750
  max distance 1
  inits MEM[(unsigned int *)&fib + 4B]
  references:
    fib[i_16] (id 0, write)
      offset 0
      distance 0
    fib[pretmp_19] (id 1)
      offset 0
      distance 0
    fib[pretmp_22] (id 2)
      offset 1
      distance 1

Analyzing # of iterations of loop 1
  exit condition [997, + , 4294967295] != 0
  bounds on difference of bases: -997 ... -997
  result:
    # of iterations 997, bounded by 997
Unrolling 2 times.

Updating SSA:
creating PHI node in block #5 for .MEM_12
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement _10 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _11 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement i_13 = i_16 + 1;
Updating SSA information for statement ivtmp_8 = ivtmp_6 - 1;
Updating SSA information for statement if (ivtmp_8 != 0)
Registering new PHI nodes in block #4
Updating SSA information for statement pretmp_19 = i_13 + -1;
Updating SSA information for statement pretmp_20 = fib[pretmp_19];
Updating SSA information for statement pretmp_22 = i_13 + -2;
Updating SSA information for statement pretmp_23 = fib[pretmp_22];
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement _27 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _26 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement i_7 = i_16 + 1;
Updating SSA information for statement ivtmp_9 = ivtmp_6 - 1;
Updating SSA information for statement if (ivtmp_8 != 0)
Registering new PHI nodes in block #7
Updating SSA information for statement pretmp_28 = i_13 + -1;
Updating SSA information for statement pretmp_29 = fib[pretmp_19];
Updating SSA information for statement pretmp_30 = i_13 + -2;
Updating SSA information for statement pretmp_31 = fib[pretmp_22];
Registering new PHI nodes in block #5
Updating SSA information for statement return;

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

ivtmp_1 -> { ivtmp_6 }
prephitmp_2 -> { prephitmp_24 }
i_7 -> { i_13 }
ivtmp_9 -> { ivtmp_8 }
prephitmp_14 -> { prephitmp_21 }
.MEM_15 -> { .MEM_17 }
i_18 -> { i_16 }
.MEM_25 -> { .MEM_12 }
_26 -> { _11 }
_27 -> { _10 }
pretmp_28 -> { pretmp_19 }
pretmp_29 -> { pretmp_20 }
pretmp_30 -> { pretmp_22 }
pretmp_31 -> { pretmp_23 }
.MEM_32 -> { .MEM_12 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 11
Number of blocks to update: 7 ( 64%)
Affected blocks: 3 4 5 6 7 9 10


Removing basic block 12
basic block 12, loop depth 0
 pred:      
 succ:       5



Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement fib[0] = 0;
Updating SSA information for statement fib[1] = 1;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _40 = MEM[(unsigned int *)&fib + 4B];
Registering new PHI nodes in block #3
Updating SSA information for statement fib[i_16] = _11;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #11
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement fib[i_18] = _26;
Registering new PHI nodes in block #7
Updating SSA information for statement pretmp_29 = fib[pretmp_28];
Updating SSA information for statement pretmp_31 = fib[pretmp_30];
Registering new PHI nodes in block #5
Updating SSA information for statement return;

Symbols to be put in SSA form
{ D.1502 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 13
Number of blocks to update: 11 ( 85%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11


Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       10



Updating SSA:
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement _10 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _11 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement fib_I_lsm1.6_39 = _11;
Updating SSA information for statement i_13 = i_16 + 1;
Updating SSA information for statement ivtmp_8 = ivtmp_6 - 1;
Registering new PHI nodes in block #4
Updating SSA information for statement pretmp_19 = i_13 + -1;
Updating SSA information for statement pretmp_20 = fib_I_lsm1.6_39;
Updating SSA information for statement pretmp_22 = i_13 + -2;
Updating SSA information for statement pretmp_23 = fib_I_lsm0.5_38;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #13
Updating SSA information for statement _47 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _48 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement fib_I_lsm1.6_50 = _11;
Updating SSA information for statement i_51 = i_16 + 1;
Updating SSA information for statement ivtmp_52 = ivtmp_6 - 1;
Registering new PHI nodes in block #14
Updating SSA information for statement pretmp_53 = i_13 + -1;
Updating SSA information for statement pretmp_54 = fib_I_lsm1.6_39;
Updating SSA information for statement pretmp_55 = i_13 + -2;
Updating SSA information for statement pretmp_56 = fib_I_lsm0.5_38;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #5

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

i_41 -> { i_16 }
.MEM_42 -> { .MEM_17 }
prephitmp_43 -> { prephitmp_21 }
prephitmp_44 -> { prephitmp_24 }
ivtmp_45 -> { ivtmp_6 }
fib_I_lsm0.5_46 -> { fib_I_lsm0.5_38 }
_47 -> { _10 }
_48 -> { _11 }
.MEM_49 -> { .MEM_12 }
fib_I_lsm1.6_50 -> { fib_I_lsm1.6_39 }
i_51 -> { i_13 }
ivtmp_52 -> { ivtmp_8 }
pretmp_53 -> { pretmp_19 }
pretmp_54 -> { pretmp_20 }
pretmp_55 -> { pretmp_22 }
pretmp_56 -> { pretmp_23 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 17
Number of blocks to update: 7 ( 41%)
Affected blocks: 3 4 10 11 13 14 15


Merging blocks 2 and 8
Merging blocks 3 and 4
Removing basic block 11
basic block 11, loop depth 1
 pred:      
 succ:       13


Merging blocks 2 and 9
Merging blocks 3 and 13
Merging blocks 3 and 14
count_fib ()
{
  unsigned int fib_I_lsm1.6;
  unsigned int fib_I_lsm0.5;
  int i;
  unsigned int ivtmp_1;
  unsigned int prephitmp_2;
  unsigned int ivtmp_6;
  unsigned int ivtmp_8;
  unsigned int ivtmp_9;
  unsigned int _10;
  unsigned int _11;
  unsigned int prephitmp_14;
  int pretmp_19;
  unsigned int pretmp_20;
  unsigned int prephitmp_21;
  int pretmp_22;
  unsigned int pretmp_23;
  unsigned int prephitmp_24;
  unsigned int _26;
  unsigned int _27;
  int pretmp_28;
  unsigned int pretmp_29;
  int pretmp_30;
  unsigned int pretmp_31;
  unsigned int pretmp_35;
  unsigned int pretmp_36;
  unsigned int ivtmp_37;
  unsigned int _40;
  unsigned int _47;
  unsigned int _48;
  unsigned int ivtmp_52;
  int pretmp_53;
  unsigned int pretmp_54;
  int pretmp_55;
  unsigned int pretmp_56;
  unsigned int ivtmp_57;
  unsigned int ivtmp_58;

  <bb 2>:
  fib[0] = 0;
  fib[1] = 1;
  _40 = MEM[(unsigned int *)&fib + 4B];

  <bb 3>:
  # i_16 = PHI <2(2), i_51(4)>
  # prephitmp_21 = PHI <1(2), pretmp_54(4)>
  # prephitmp_24 = PHI <0(2), pretmp_56(4)>
  # ivtmp_6 = PHI <998(2), ivtmp_52(4)>
  # fib_I_lsm0.5_38 = PHI <_40(2), fib_I_lsm0.5_50(4)>
  # ivtmp_57 = PHI <997(2), ivtmp_58(4)>
  _10 = prephitmp_21 + prephitmp_24;
  _11 = _10 & 65535;
  fib[i_16] = _11;
  fib_I_lsm1.6_39 = _11;
  i_13 = i_16 + 1;
  ivtmp_8 = ivtmp_6 - 1;
  pretmp_19 = i_13 + -1;
  pretmp_20 = fib_I_lsm1.6_39;
  pretmp_22 = i_13 + -2;
  pretmp_23 = fib_I_lsm0.5_38;
  _47 = pretmp_20 + pretmp_23;
  _48 = _47 & 65535;
  fib[i_13] = _48;
  fib_I_lsm0.5_50 = _48;
  i_51 = i_13 + 1;
  ivtmp_52 = ivtmp_8 + 4294967295;
  pretmp_53 = i_51 + -1;
  pretmp_54 = fib_I_lsm0.5_50;
  pretmp_55 = i_51 + -2;
  pretmp_56 = fib_I_lsm1.6_39;
  ivtmp_58 = ivtmp_57 - 2;
  if (ivtmp_58 > 1)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:
  # i_33 = PHI <i_51(3)>
  # pretmp_35 = PHI <pretmp_54(3)>
  # pretmp_36 = PHI <pretmp_56(3)>
  # ivtmp_37 = PHI <ivtmp_52(3)>

  <bb 6>:
  # i_18 = PHI <i_33(5), i_7(7)>
  # prephitmp_14 = PHI <pretmp_35(5), pretmp_29(7)>
  # prephitmp_2 = PHI <pretmp_36(5), pretmp_31(7)>
  # ivtmp_1 = PHI <ivtmp_37(5), ivtmp_9(7)>
  _27 = prephitmp_14 + prephitmp_2;
  _26 = _27 & 65535;
  fib[i_18] = _26;
  i_7 = i_18 + 1;
  ivtmp_9 = ivtmp_1 - 1;
  if (ivtmp_9 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  pretmp_28 = i_7 + -1;
  pretmp_29 = fib[pretmp_28];
  pretmp_30 = i_7 + -2;
  pretmp_31 = fib[pretmp_30];
  goto <bb 6>;

  <bb 8>:
  return;

}



;; Function count_averages (count_averages, funcdef_no=1, decl_uid=1465, cgraph_uid=1, symbol_order=3)

Processing loop 1
Creating dr for fib[_5]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {0, +, 1}_1
Creating dr for fib[i_9]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for avg[i_17]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &avg
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: avg
	Access function 0: {1, +, 1}_1
(compute_affine_dependence
  stmt_a: _6 = fib[_5];
  stmt_b: _10 = fib[i_9];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _6 = fib[_5];
  stmt_b: avg[i_17] = _13;
) -> no dependence
(compute_affine_dependence
  stmt_a: _10 = fib[i_9];
  stmt_b: avg[i_17] = _13;
) -> no dependence
(compute_affine_dependence
  stmt_a: _6 = fib[_5];
  stmt_b: _6 = fib[_5];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _10 = fib[i_9];
  stmt_b: _10 = fib[i_9];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: avg[i_17] = _13;
  stmt_b: avg[i_17] = _13;
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: _6 = fib[_5];
#  ref: fib[_5];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: _10 = fib[i_9];
#  ref: fib[i_9];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 996
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 996
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: _6 = fib[_5];
#  ref: fib[_5];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: avg[i_17] = _13;
#  ref: avg[i_17];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: _10 = fib[i_9];
#  ref: fib[i_9];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: avg[i_17] = _13;
#  ref: avg[i_17];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: _6 = fib[_5];
#  ref: fib[_5];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: _6 = fib[_5];
#  ref: fib[_5];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: _10 = fib[i_9];
#  ref: fib[i_9];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: _10 = fib[i_9];
#  ref: fib[i_9];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 5 
#  stmt: avg[i_17] = _13;
#  ref: avg[i_17];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
#(Data Ref: 
#  bb: 5 
#  stmt: avg[i_17] = _13;
#  ref: avg[i_17];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {1, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    avg[i_17] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    fib[_5] (id 0)
      offset 0
      distance 0
    fib[i_9] (id 1)
      offset 0
      distance 0

analyze_innermost: success.
Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Loads-only chain 0x14161d6c0
  max distance 2, may reuse first
  inits MEM[(unsigned int *)&fib] pretmp_30
  references:
    fib[i_9] (id 1)
      offset -2
      distance 0
    looparound ref
      in statement prephitmp_31 = PHI <pretmp_30(4), _10(6)>

      distance 1
    fib[_5] (id 0)
      offset 0
      distance 2

Analyzing # of iterations of loop 1
  exit condition [2, + , 1](no_overflow) < n_4(D)
  bounds on difference of bases: 0 ... 2147483645
  result:
    # of iterations (unsigned int) n_4(D) + 4294967294, bounded by 2147483645
Unrolling 2 times.

Updating SSA:
Registering new PHI nodes in block #2
Registering new PHI nodes in block #4
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #5
Updating SSA information for statement _5 = i_17 + -1;
Updating SSA information for statement _6 = fib[_5];
Updating SSA information for statement i_9 = i_17 + 1;
Updating SSA information for statement _10 = fib[i_9];
Updating SSA information for statement _1 = _6 + _10;
Updating SSA information for statement _11 = _1 + prephitmp_31;
Updating SSA information for statement _12 = _11 / 3;
Updating SSA information for statement _13 = _12 & 65535;
Updating SSA information for statement avg[i_17] = _13;
Updating SSA information for statement if (n_4(D) > i_9)
Registering new PHI nodes in block #6
Registering new PHI nodes in block #11
Registering new PHI nodes in block #7
Updating SSA information for statement _24 = i_17 + -1;
Updating SSA information for statement _23 = fib[_5];
Updating SSA information for statement i_22 = i_17 + 1;
Updating SSA information for statement _21 = fib[i_9];
Updating SSA information for statement _20 = _6 + _10;
Updating SSA information for statement _16 = _1 + prephitmp_31;
Updating SSA information for statement _15 = _11 / 3;
Updating SSA information for statement _8 = _12 & 65535;
Updating SSA information for statement avg[i_17] = _13;
Updating SSA information for statement if (n_4(D) > i_9)
Registering new PHI nodes in block #8
Registering new PHI nodes in block #3

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_2 -> { .MEM_14 }
_8 -> { _13 }
_15 -> { _12 }
_16 -> { _11 }
_20 -> { _1 }
_21 -> { _10 }
i_22 -> { i_9 }
_23 -> { _6 }
_24 -> { _5 }
prephitmp_25 -> { prephitmp_31 }
.MEM_26 -> { .MEM_18 }
i_27 -> { i_17 }
Incremental SSA update started at block: 2
Number of blocks in CFG: 12
Number of blocks to update: 7 ( 58%)
Affected blocks: 3 5 6 7 8 10 11


Removing basic block 13
basic block 13, loop depth 0
 pred:      
goto <bb 3>;
 succ:       3



Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #4
Updating SSA information for statement pretmp_30 = fib[1];
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Updating SSA information for statement _36 = MEM[(unsigned int *)&fib];
Registering new PHI nodes in block #5
Updating SSA information for statement _10 = fib[i_9];
Updating SSA information for statement avg[i_17] = _13;
Registering new PHI nodes in block #6
Registering new PHI nodes in block #12
Registering new PHI nodes in block #11
Registering new PHI nodes in block #7
Updating SSA information for statement _23 = fib[_24];
Updating SSA information for statement _21 = fib[i_22];
Updating SSA information for statement avg[i_27] = _8;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #3
Updating SSA information for statement return;

Symbols to be put in SSA form
{ D.1503 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 14
Number of blocks to update: 12 ( 86%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12


Removing basic block 17
basic block 17, loop depth 0
 pred:      
 succ:       11



Updating SSA:
Registering new PHI nodes in block #9
Registering new PHI nodes in block #10
Registering new PHI nodes in block #5
Updating SSA information for statement prephitmp_31 = fib_I_lsm1.42_34;
Updating SSA information for statement _5 = i_17 + -1;
Updating SSA information for statement _6 = fib_I_lsm0.41_33;
Updating SSA information for statement i_9 = i_17 + 1;
Updating SSA information for statement _10 = fib[i_9];
Updating SSA information for statement fib_I_lsm0.41_35 = _10;
Updating SSA information for statement _1 = _6 + _10;
Updating SSA information for statement _11 = _1 + prephitmp_31;
Updating SSA information for statement _12 = _11 / 3;
Updating SSA information for statement _13 = _12 & 65535;
Updating SSA information for statement avg[i_17] = _13;
Registering new PHI nodes in block #6
Registering new PHI nodes in block #12
Registering new PHI nodes in block #14
Updating SSA information for statement prephitmp_41 = fib_I_lsm1.42_34;
Updating SSA information for statement _42 = i_17 + -1;
Updating SSA information for statement _43 = fib_I_lsm0.41_33;
Updating SSA information for statement i_44 = i_17 + 1;
Updating SSA information for statement _45 = fib[i_9];
Updating SSA information for statement fib_I_lsm0.41_46 = _10;
Updating SSA information for statement _47 = _6 + _10;
Updating SSA information for statement _48 = _1 + prephitmp_31;
Updating SSA information for statement _49 = _11 / 3;
Updating SSA information for statement _50 = _12 & 65535;
Updating SSA information for statement avg[i_17] = _13;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #16
Registering new PHI nodes in block #11
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

i_37 -> { i_17 }
.MEM_38 -> { .MEM_18 }
fib_I_lsm0.41_39 -> { fib_I_lsm0.41_33 }
fib_I_lsm1.42_40 -> { fib_I_lsm1.42_34 }
prephitmp_41 -> { prephitmp_31 }
_42 -> { _5 }
_43 -> { _6 }
i_44 -> { i_9 }
_45 -> { _10 }
fib_I_lsm0.41_46 -> { fib_I_lsm0.41_35 }
_47 -> { _1 }
_48 -> { _11 }
_49 -> { _12 }
_50 -> { _13 }
.MEM_51 -> { .MEM_14 }
Incremental SSA update started at block: 9
Number of blocks in CFG: 18
Number of blocks to update: 6 ( 33%)
Affected blocks: 5 11 12 14 15 16


Merging blocks 4 and 9
Merging blocks 5 and 6
Removing basic block 12
basic block 12, loop depth 1
 pred:      
 succ:       14


Merging blocks 5 and 14
Merging blocks 5 and 15
count_averages (int n)
{
  unsigned int fib_I_lsm1.42;
  unsigned int fib_I_lsm0.41;
  int i;
  long unsigned int _1;
  int _5;
  unsigned int _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  unsigned int _13;
  long unsigned int _15;
  long unsigned int _16;
  int _19;
  long unsigned int _20;
  unsigned int _21;
  unsigned int _23;
  int _24;
  unsigned int prephitmp_25;
  unsigned int pretmp_30;
  unsigned int prephitmp_31;
  unsigned int _36;
  unsigned int prephitmp_41;
  int _42;
  unsigned int _43;
  unsigned int _45;
  long unsigned int _47;
  long unsigned int _48;
  long unsigned int _49;
  unsigned int _50;
  int ivtmp_52;
  int ivtmp_53;

  <bb 2>:
  if (n_4(D) > 1)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  return;

  <bb 4>:
  pretmp_30 = fib[1];
  _19 = n_4(D) + -1;
  if (n_4(D) > 3)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _36 = MEM[(unsigned int *)&fib];

  <bb 6>:
  # i_17 = PHI <1(5), i_44(7)>
  # fib_I_lsm0.41_33 = PHI <_36(5), fib_I_lsm0.41_35(7)>
  # fib_I_lsm1.42_34 = PHI <pretmp_30(5), fib_I_lsm1.42_46(7)>
  # ivtmp_52 = PHI <2(5), ivtmp_53(7)>
  prephitmp_31 = fib_I_lsm1.42_34;
  _5 = i_17 + -1;
  _6 = fib_I_lsm0.41_33;
  i_9 = i_17 + 1;
  _10 = fib[i_9];
  fib_I_lsm0.41_35 = _10;
  _1 = _6 + _10;
  _11 = _1 + prephitmp_31;
  _12 = _11 / 3;
  _13 = _12 & 65535;
  avg[i_17] = _13;
  prephitmp_41 = fib_I_lsm0.41_35;
  _42 = i_9 + -1;
  _43 = fib_I_lsm1.42_34;
  i_44 = i_9 + 1;
  _45 = fib[i_44];
  fib_I_lsm1.42_46 = _45;
  _47 = _43 + _45;
  _48 = _47 + prephitmp_41;
  _49 = _48 / 3;
  _50 = _49 & 65535;
  avg[i_9] = _50;
  ivtmp_53 = ivtmp_52 + 2;
  if (ivtmp_53 < _19)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  # i_32 = PHI <1(4), i_44(6)>
  # _7 = PHI <pretmp_30(4), _45(6)>

  <bb 9>:
  # i_27 = PHI <i_32(8), i_22(10)>
  # prephitmp_25 = PHI <_7(8), _21(10)>
  _24 = i_27 + -1;
  _23 = fib[_24];
  i_22 = i_27 + 1;
  _21 = fib[i_22];
  _20 = _23 + _21;
  _16 = _20 + prephitmp_25;
  _15 = _16 / 3;
  _8 = _15 & 65535;
  avg[i_27] = _8;
  if (n_4(D) > i_22)
    goto <bb 10>;
  else
    goto <bb 3>;

  <bb 10>:
  goto <bb 9>;

}


