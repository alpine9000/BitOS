
;; Function main (main, funcdef_no=0, decl_uid=1457, cgraph_uid=0, symbol_order=4) (executed once)

Processing loop 1
Creating dr for d[pretmp_21][c.1_18]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: (ssizetype) ((sizetype) pretmp_19 * 8)
	constant offset from base address: 24
	step: 4
	aligned to: 8
	base_object: d
	Access function 0: {0, +, 1}_1
	Access function 1: pretmp_21
Creating dr for d[pretmp_22][c.1_18]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: (ssizetype) ((sizetype) pretmp_19 * 8)
	constant offset from base address: 32
	step: 4
	aligned to: 8
	base_object: d
	Access function 0: {0, +, 1}_1
	Access function 1: pretmp_22
(compute_affine_dependence
  stmt_a: _7 = d[pretmp_21][c.1_18];
  stmt_b: _9 = d[pretmp_22][c.1_18];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
(analyze_overlapping_iterations 
  (chrec_a = pretmp_21)
  (chrec_b = pretmp_22)
  (overlap_iterations_a = not known)
  (overlap_iterations_b = not known))
) -> dependence analysis failed
(compute_affine_dependence
  stmt_a: _7 = d[pretmp_21][c.1_18];
  stmt_b: _7 = d[pretmp_21][c.1_18];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
(analyze_overlapping_iterations 
  (chrec_a = pretmp_21)
  (chrec_b = pretmp_21)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _9 = d[pretmp_22][c.1_18];
  stmt_b: _9 = d[pretmp_22][c.1_18];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
(analyze_overlapping_iterations 
  (chrec_a = pretmp_22)
  (chrec_b = pretmp_22)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _7 = d[pretmp_21][c.1_18];
#  ref: d[pretmp_21][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_21
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = d[pretmp_22][c.1_18];
#  ref: d[pretmp_22][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_22
#)
    (don't know)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _7 = d[pretmp_21][c.1_18];
#  ref: d[pretmp_21][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_21
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _7 = d[pretmp_21][c.1_18];
#  ref: d[pretmp_21][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_21
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  access_fn_A: pretmp_21
  access_fn_B: pretmp_21

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = d[pretmp_22][c.1_18];
#  ref: d[pretmp_22][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_22
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = d[pretmp_22][c.1_18];
#  ref: d[pretmp_22][c.1_18];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#  Access function 1: pretmp_22
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  access_fn_A: pretmp_22
  access_fn_B: pretmp_22

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    d[pretmp_21][c.1_18] (id 0)
      offset 0
      distance 0
    d[pretmp_22][c.1_18] (id 1)
      offset 0
      distance 0

Applying pattern match.pd:697, generic-match.c:1350
Applying pattern match.pd:625, generic-match.c:1309
Applying pattern match.pd:697, generic-match.c:1350
Applying pattern match.pd:625, generic-match.c:1309
Before commoning:

Loads-only chain 0x14162dc10
  max distance 2, may reuse first
  inits MEM[(int *)_26 + 24B] MEM[(int *)_30 + 28B]
  references:
    d[pretmp_22][c.1_18] (id 1)
      offset -2
      distance 0
    d[pretmp_21][c.1_18] (id 0)
      offset 0
      distance 2

Executing predictive commoning without unrolling.

Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement c = 0;
Updating SSA information for statement pretmp_19 = b;
Updating SSA information for statement c_lsm.7_14 = c;
Updating SSA information for statement f.2_13 = f;
Updating SSA information for statement _34 = MEM[(int *)_26 + 24B];
Updating SSA information for statement _35 = MEM[(int *)_30 + 28B];
Registering new PHI nodes in block #3
Updating SSA information for statement _9 = d[pretmp_22][c.1_18];
Registering new PHI nodes in block #9
Registering new PHI nodes in block #11
Registering new PHI nodes in block #10
Updating SSA information for statement c = c_lsm.7_8;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #6
Updating SSA information for statement c = c_lsm.7_27;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #8
Updating SSA information for statement return 0;

Symbols to be put in SSA form
{ D.1477 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 12
Number of blocks to update: 11 ( 92%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11


main ()
{
  int d_I_I_lsm1.10;
  int d_I_I_lsm0.9;
  _Bool c_lsm.8;
  unsigned int c_lsm.7;
  sizetype _1;
  unsigned int ivtmp_4;
  int _7;
  int _9;
  int _10;
  unsigned int c.3_11;
  unsigned int ivtmp_12;
  int f.2_13;
  unsigned int c.1_18;
  int pretmp_19;
  sizetype _20;
  int pretmp_21;
  int pretmp_22;
  int[5][2] * _26;
  sizetype _28;
  sizetype _29;
  int[5][2] * _30;
  int _34;
  int _35;

  <bb 2>:
  c = 0;
  pretmp_19 = b;
  pretmp_21 = pretmp_19 + 3;
  pretmp_22 = pretmp_19 + 4;
  c_lsm.7_14 = c;
  f.2_13 = f;
  _1 = (sizetype) pretmp_19;
  _20 = _1 * 8;
  _26 = &d + _20;
  _28 = (sizetype) pretmp_19;
  _29 = _28 * 8;
  _30 = &d + _29;
  _34 = MEM[(int *)_26 + 24B];
  _35 = MEM[(int *)_30 + 28B];

  <bb 3>:
  # c.1_18 = PHI <0(2), c.3_11(11)>
  # c_lsm.7_23 = PHI <c_lsm.7_14(2), c.3_11(11)>
  # c_lsm.8_15 = PHI <0(2), 1(11)>
  # ivtmp_12 = PHI <2(2), ivtmp_4(11)>
  # d_I_I_lsm0.9_31 = PHI <_34(2), d_I_I_lsm1.10_32(11)>
  # d_I_I_lsm1.10_32 = PHI <_35(2), d_I_I_lsm0.9_33(11)>
  _7 = d_I_I_lsm0.9_31;
  _9 = d[pretmp_22][c.1_18];
  d_I_I_lsm0.9_33 = _9;
  _10 = _7 & _9;
  if (_10 != 0)
    goto <bb 4>;
  else
    goto <bb 9>;

  <bb 4>:
  if (f.2_13 != 0)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  # c_lsm.8_25 = PHI <c_lsm.8_15(4)>
  # c_lsm.7_27 = PHI <c_lsm.7_23(4)>
  if (c_lsm.8_25 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  c = c_lsm.7_27;

  <bb 7>:

  <bb 8>:
  return 0;

  <bb 9>:
  c.3_11 = c.1_18 + 1;
  ivtmp_4 = ivtmp_12 - 1;
  if (ivtmp_4 != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  # c_lsm.7_8 = PHI <c.3_11(9)>
  c = c_lsm.7_8;
  goto <bb 8>;

  <bb 11>:
  goto <bb 3>;

}


