
;; Function count_fib (count_fib, funcdef_no=0, decl_uid=1457, cgraph_uid=0, symbol_order=1)

Processing loop 1
Creating dr for fib[i_16]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for fib[pretmp_19]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for fib[pretmp_22]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {1, +, 1}_1
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: pretmp_20 = fib[pretmp_19];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [1 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [1 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [1 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [1 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  1 
  )
)
)
(compute_affine_dependence
  stmt_a: pretmp_20 = fib[pretmp_19];
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [1 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [1 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [1 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [1 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  1 
  )
)
)
(compute_affine_dependence
  stmt_a: fib[i_16] = _11;
  stmt_b: fib[i_16] = _11;
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: pretmp_20 = fib[pretmp_19];
  stmt_b: pretmp_20 = fib[pretmp_19];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: pretmp_23 = fib[pretmp_22];
  stmt_b: pretmp_23 = fib[pretmp_22];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [1 + 1 * x_1]
  last_conflict: 997
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 997
  (Subscript distance: 1 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   1 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [1 + 1 * x_1]
  last_conflict: 997
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 997
  (Subscript distance: 1 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   1 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: fib[i_16] = _11;
#  ref: fib[i_16];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_20 = fib[pretmp_19];
#  ref: fib[pretmp_19];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
#(Data Ref: 
#  bb: 4 
#  stmt: pretmp_23 = fib[pretmp_22];
#  ref: fib[pretmp_22];
#  base_object: fib;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {1, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    fib[i_16] (id 0, write)
      offset 0
      distance 0
    fib[pretmp_19] (id 1)
      offset 0
      distance 0
    fib[pretmp_22] (id 2)
      offset 0
      distance 0

Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Store-loads chain 0x100f171b0
  max distance 1
  inits MEM[(long int *)&fib + 4B]
  references:
    fib[i_16] (id 0, write)
      offset 0
      distance 0
    fib[pretmp_19] (id 1)
      offset 0
      distance 0
    fib[pretmp_22] (id 2)
      offset 1
      distance 1

Analyzing # of iterations of loop 1
  exit condition [997, + , 4294967295] != 0
  bounds on difference of bases: -997 ... -997
  result:
    # of iterations 997, bounded by 997
Unrolling 2 times.

Updating SSA:
creating PHI node in block #5 for .MEM_12
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement _10 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _11 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement i_13 = i_16 + 1;
Updating SSA information for statement ivtmp_8 = ivtmp_6 - 1;
Updating SSA information for statement if (ivtmp_8 != 0)
Registering new PHI nodes in block #4
Updating SSA information for statement pretmp_19 = i_13 + -1;
Updating SSA information for statement pretmp_20 = fib[pretmp_19];
Updating SSA information for statement pretmp_22 = i_13 + -2;
Updating SSA information for statement pretmp_23 = fib[pretmp_22];
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement _27 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _26 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement i_7 = i_16 + 1;
Updating SSA information for statement ivtmp_9 = ivtmp_6 - 1;
Updating SSA information for statement if (ivtmp_8 != 0)
Registering new PHI nodes in block #7
Updating SSA information for statement pretmp_28 = i_13 + -1;
Updating SSA information for statement pretmp_29 = fib[pretmp_19];
Updating SSA information for statement pretmp_30 = i_13 + -2;
Updating SSA information for statement pretmp_31 = fib[pretmp_22];
Registering new PHI nodes in block #5
Updating SSA information for statement return;

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

ivtmp_1 -> { ivtmp_6 }
prephitmp_2 -> { prephitmp_24 }
i_7 -> { i_13 }
ivtmp_9 -> { ivtmp_8 }
prephitmp_14 -> { prephitmp_21 }
.MEM_15 -> { .MEM_17 }
i_18 -> { i_16 }
.MEM_25 -> { .MEM_12 }
_26 -> { _11 }
_27 -> { _10 }
pretmp_28 -> { pretmp_19 }
pretmp_29 -> { pretmp_20 }
pretmp_30 -> { pretmp_22 }
pretmp_31 -> { pretmp_23 }
.MEM_32 -> { .MEM_12 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 11
Number of blocks to update: 7 ( 64%)
Affected blocks: 3 4 5 6 7 9 10


Removing basic block 12
basic block 12, loop depth 0
 pred:      
 succ:       5



Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement fib[0] = 0;
Updating SSA information for statement fib[1] = 1;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _40 = MEM[(long int *)&fib + 4B];
Registering new PHI nodes in block #3
Updating SSA information for statement fib[i_16] = _11;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #11
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement fib[i_18] = _26;
Registering new PHI nodes in block #7
Updating SSA information for statement pretmp_29 = fib[pretmp_28];
Updating SSA information for statement pretmp_31 = fib[pretmp_30];
Registering new PHI nodes in block #5
Updating SSA information for statement return;

Symbols to be put in SSA form
{ D.1502 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 13
Number of blocks to update: 11 ( 85%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11


Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       10



Updating SSA:
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement _10 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _11 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement fib_I_lsm1.6_39 = _11;
Updating SSA information for statement i_13 = i_16 + 1;
Updating SSA information for statement ivtmp_8 = ivtmp_6 - 1;
Registering new PHI nodes in block #4
Updating SSA information for statement pretmp_19 = i_13 + -1;
Updating SSA information for statement pretmp_20 = fib_I_lsm1.6_39;
Updating SSA information for statement pretmp_22 = i_13 + -2;
Updating SSA information for statement pretmp_23 = fib_I_lsm0.5_38;
Registering new PHI nodes in block #11
Registering new PHI nodes in block #13
Updating SSA information for statement _47 = prephitmp_21 + prephitmp_24;
Updating SSA information for statement _48 = _10 & 65535;
Updating SSA information for statement fib[i_16] = _11;
Updating SSA information for statement fib_I_lsm1.6_50 = _11;
Updating SSA information for statement i_51 = i_16 + 1;
Updating SSA information for statement ivtmp_52 = ivtmp_6 - 1;
Registering new PHI nodes in block #14
Updating SSA information for statement pretmp_53 = i_13 + -1;
Updating SSA information for statement pretmp_54 = fib_I_lsm1.6_39;
Updating SSA information for statement pretmp_55 = i_13 + -2;
Updating SSA information for statement pretmp_56 = fib_I_lsm0.5_38;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #5

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

i_41 -> { i_16 }
.MEM_42 -> { .MEM_17 }
prephitmp_43 -> { prephitmp_21 }
prephitmp_44 -> { prephitmp_24 }
ivtmp_45 -> { ivtmp_6 }
fib_I_lsm0.5_46 -> { fib_I_lsm0.5_38 }
_47 -> { _10 }
_48 -> { _11 }
.MEM_49 -> { .MEM_12 }
fib_I_lsm1.6_50 -> { fib_I_lsm1.6_39 }
i_51 -> { i_13 }
ivtmp_52 -> { ivtmp_8 }
pretmp_53 -> { pretmp_19 }
pretmp_54 -> { pretmp_20 }
pretmp_55 -> { pretmp_22 }
pretmp_56 -> { pretmp_23 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 17
Number of blocks to update: 7 ( 41%)
Affected blocks: 3 4 10 11 13 14 15


Merging blocks 2 and 8
Merging blocks 3 and 4
Removing basic block 11
basic block 11, loop depth 1
 pred:      
 succ:       13


Merging blocks 2 and 9
Merging blocks 3 and 13
Merging blocks 3 and 14
count_fib ()
{
  long int fib_I_lsm1.6;
  long int fib_I_lsm0.5;
  int i;
  unsigned int ivtmp_1;
  long int prephitmp_2;
  unsigned int ivtmp_6;
  unsigned int ivtmp_8;
  unsigned int ivtmp_9;
  long int _10;
  long int _11;
  long int prephitmp_14;
  int pretmp_19;
  long int pretmp_20;
  long int prephitmp_21;
  int pretmp_22;
  long int pretmp_23;
  long int prephitmp_24;
  long int _26;
  long int _27;
  int pretmp_28;
  long int pretmp_29;
  int pretmp_30;
  long int pretmp_31;
  long int pretmp_35;
  long int pretmp_36;
  unsigned int ivtmp_37;
  long int _40;
  long int _47;
  long int _48;
  unsigned int ivtmp_52;
  int pretmp_53;
  long int pretmp_54;
  int pretmp_55;
  long int pretmp_56;
  unsigned int ivtmp_57;
  unsigned int ivtmp_58;

  <bb 2>:
  fib[0] = 0;
  fib[1] = 1;
  _40 = MEM[(long int *)&fib + 4B];

  <bb 3>:
  # i_16 = PHI <2(2), i_51(4)>
  # prephitmp_21 = PHI <1(2), pretmp_54(4)>
  # prephitmp_24 = PHI <0(2), pretmp_56(4)>
  # ivtmp_6 = PHI <998(2), ivtmp_52(4)>
  # fib_I_lsm0.5_38 = PHI <_40(2), fib_I_lsm0.5_50(4)>
  # ivtmp_57 = PHI <997(2), ivtmp_58(4)>
  _10 = prephitmp_21 + prephitmp_24;
  _11 = _10 & 65535;
  fib[i_16] = _11;
  fib_I_lsm1.6_39 = _11;
  i_13 = i_16 + 1;
  ivtmp_8 = ivtmp_6 - 1;
  pretmp_19 = i_13 + -1;
  pretmp_20 = fib_I_lsm1.6_39;
  pretmp_22 = i_13 + -2;
  pretmp_23 = fib_I_lsm0.5_38;
  _47 = pretmp_20 + pretmp_23;
  _48 = _47 & 65535;
  fib[i_13] = _48;
  fib_I_lsm0.5_50 = _48;
  i_51 = i_13 + 1;
  ivtmp_52 = ivtmp_8 + 4294967295;
  pretmp_53 = i_51 + -1;
  pretmp_54 = fib_I_lsm0.5_50;
  pretmp_55 = i_51 + -2;
  pretmp_56 = fib_I_lsm1.6_39;
  ivtmp_58 = ivtmp_57 - 2;
  if (ivtmp_58 > 1)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:
  # i_33 = PHI <i_51(3)>
  # pretmp_35 = PHI <pretmp_54(3)>
  # pretmp_36 = PHI <pretmp_56(3)>
  # ivtmp_37 = PHI <ivtmp_52(3)>

  <bb 6>:
  # i_18 = PHI <i_33(5), i_7(7)>
  # prephitmp_14 = PHI <pretmp_35(5), pretmp_29(7)>
  # prephitmp_2 = PHI <pretmp_36(5), pretmp_31(7)>
  # ivtmp_1 = PHI <ivtmp_37(5), ivtmp_9(7)>
  _27 = prephitmp_14 + prephitmp_2;
  _26 = _27 & 65535;
  fib[i_18] = _26;
  i_7 = i_18 + 1;
  ivtmp_9 = ivtmp_1 - 1;
  if (ivtmp_9 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  pretmp_28 = i_7 + -1;
  pretmp_29 = fib[pretmp_28];
  pretmp_30 = i_7 + -2;
  pretmp_31 = fib[pretmp_30];
  goto <bb 6>;

  <bb 8>:
  return;

}



;; Function count_averages (count_averages, funcdef_no=1, decl_uid=1465, cgraph_uid=1, symbol_order=3)

Processing loop 1
Creating dr for fib[_4]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {0, +, 1}_1
Creating dr for fib[i_8]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &fib
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: fib
	Access function 0: {2, +, 1}_1
Creating dr for avg[i_16]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &avg
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: avg
	Access function 0: {1, +, 1}_1
(compute_affine_dependence
  stmt_a: _5 = fib[_4];
  stmt_b: _9 = fib[i_8];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _5 = fib[_4];
  stmt_b: avg[i_16] = _12;
) -> no dependence
(compute_affine_dependence
  stmt_a: _9 = fib[i_8];
  stmt_b: avg[i_16] = _12;
) -> no dependence
(compute_affine_dependence
  stmt_a: _5 = fib[_4];
  stmt_b: _5 = fib[_4];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _9 = fib[i_8];
  stmt_b: _9 = fib[i_8];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_1)
  (chrec_b = {2, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: avg[i_16] = _12;
  stmt_b: avg[i_16] = _12;
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_1)
  (chrec_b = {1, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _5 = fib[_4];
#  ref: fib[_4];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = fib[i_8];
#  ref: fib[i_8];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 996
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 996
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _5 = fib[_4];
#  ref: fib[_4];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: avg[i_16] = _12;
#  ref: avg[i_16];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = fib[i_8];
#  ref: fib[i_8];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: avg[i_16] = _12;
#  ref: avg[i_16];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _5 = fib[_4];
#  ref: fib[_4];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _5 = fib[_4];
#  ref: fib[_4];
#  base_object: fib;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = fib[i_8];
#  ref: fib[i_8];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: _9 = fib[i_8];
#  ref: fib[i_8];
#  base_object: fib;
#  Access function 0: {2, +, 1}_1
#)
  access_fn_A: {2, +, 1}_1
  access_fn_B: {2, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: avg[i_16] = _12;
#  ref: avg[i_16];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: avg[i_16] = _12;
#  ref: avg[i_16];
#  base_object: avg;
#  Access function 0: {1, +, 1}_1
#)
  access_fn_A: {1, +, 1}_1
  access_fn_B: {1, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    avg[i_16] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    fib[_4] (id 0)
      offset 0
      distance 0
    fib[i_8] (id 1)
      offset 0
      distance 0

analyze_innermost: success.
Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Loads-only chain 0x100f17f70
  max distance 2, may reuse first
  inits MEM[(long int *)&fib] pretmp_28
  references:
    fib[i_8] (id 1)
      offset -2
      distance 0
    looparound ref
      in statement prephitmp_29 = PHI <_9(4), pretmp_28(2)>

      distance 1
    fib[_4] (id 0)
      offset 0
      distance 2

Analyzing # of iterations of loop 1
  exit condition [997, + , 4294967295] != 0
  bounds on difference of bases: -997 ... -997
  result:
    # of iterations 997, bounded by 997
Unrolling 2 times.

Updating SSA:
creating PHI node in block #5 for .MEM_13
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement _4 = i_16 + -1;
Updating SSA information for statement _5 = fib[_4];
Updating SSA information for statement _7 = _5 + prephitmp_29;
Updating SSA information for statement i_8 = i_16 + 1;
Updating SSA information for statement _9 = fib[i_8];
Updating SSA information for statement _10 = _7 + _9;
Updating SSA information for statement _11 = _10 / 3;
Updating SSA information for statement _12 = _11 & 65535;
Updating SSA information for statement avg[i_16] = _12;
Updating SSA information for statement ivtmp_25 = ivtmp_26 - 1;
Updating SSA information for statement if (ivtmp_25 != 0)
Registering new PHI nodes in block #4
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement _20 = i_16 + -1;
Updating SSA information for statement _19 = fib[_4];
Updating SSA information for statement _18 = _5 + prephitmp_29;
Updating SSA information for statement i_15 = i_16 + 1;
Updating SSA information for statement _14 = fib[i_8];
Updating SSA information for statement _2 = _7 + _9;
Updating SSA information for statement _1 = _10 / 3;
Updating SSA information for statement _30 = _11 & 65535;
Updating SSA information for statement avg[i_16] = _12;
Updating SSA information for statement ivtmp_6 = ivtmp_26 - 1;
Updating SSA information for statement if (ivtmp_25 != 0)
Registering new PHI nodes in block #7
Registering new PHI nodes in block #5
Updating SSA information for statement return;

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

_1 -> { _11 }
_2 -> { _10 }
ivtmp_6 -> { ivtmp_25 }
_14 -> { _9 }
i_15 -> { i_8 }
_18 -> { _7 }
_19 -> { _5 }
_20 -> { _4 }
ivtmp_21 -> { ivtmp_26 }
prephitmp_22 -> { prephitmp_29 }
.MEM_23 -> { .MEM_17 }
i_24 -> { i_16 }
.MEM_27 -> { .MEM_13 }
_30 -> { _12 }
.MEM_31 -> { .MEM_13 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 11
Number of blocks to update: 7 ( 64%)
Affected blocks: 3 4 5 6 7 9 10


Removing basic block 12
basic block 12, loop depth 0
 pred:      
 succ:       5



Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Updating SSA information for statement pretmp_28 = fib[1];
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _39 = MEM[(long int *)&fib];
Registering new PHI nodes in block #3
Updating SSA information for statement _9 = fib[i_8];
Updating SSA information for statement avg[i_16] = _12;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #11
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement _19 = fib[_20];
Updating SSA information for statement _14 = fib[i_15];
Updating SSA information for statement avg[i_24] = _30;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #5
Updating SSA information for statement return;

Symbols to be put in SSA form
{ D.1503 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 13
Number of blocks to update: 11 ( 85%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11


Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       10



Updating SSA:
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #3
Updating SSA information for statement prephitmp_29 = fib_I_lsm1.42_37;
Updating SSA information for statement _4 = i_16 + -1;
Updating SSA information for statement _5 = fib_I_lsm0.41_36;
Updating SSA information for statement _7 = _5 + prephitmp_29;
Updating SSA information for statement i_8 = i_16 + 1;
Updating SSA information for statement _9 = fib[i_8];
Updating SSA information for statement fib_I_lsm0.41_38 = _9;
Updating SSA information for statement _10 = _7 + _9;
Updating SSA information for statement _11 = _10 / 3;
Updating SSA information for statement _12 = _11 & 65535;
Updating SSA information for statement avg[i_16] = _12;
Updating SSA information for statement ivtmp_25 = ivtmp_26 - 1;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #11
Registering new PHI nodes in block #13
Updating SSA information for statement prephitmp_45 = fib_I_lsm1.42_37;
Updating SSA information for statement _46 = i_16 + -1;
Updating SSA information for statement _47 = fib_I_lsm0.41_36;
Updating SSA information for statement _48 = _5 + prephitmp_29;
Updating SSA information for statement i_49 = i_16 + 1;
Updating SSA information for statement _50 = fib[i_8];
Updating SSA information for statement fib_I_lsm0.41_51 = _9;
Updating SSA information for statement _52 = _7 + _9;
Updating SSA information for statement _53 = _10 / 3;
Updating SSA information for statement _54 = _11 & 65535;
Updating SSA information for statement avg[i_16] = _12;
Updating SSA information for statement ivtmp_56 = ivtmp_26 - 1;
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Registering new PHI nodes in block #7
Registering new PHI nodes in block #5

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

i_40 -> { i_16 }
.MEM_41 -> { .MEM_17 }
ivtmp_42 -> { ivtmp_26 }
fib_I_lsm0.41_43 -> { fib_I_lsm0.41_36 }
fib_I_lsm1.42_44 -> { fib_I_lsm1.42_37 }
prephitmp_45 -> { prephitmp_29 }
_46 -> { _4 }
_47 -> { _5 }
_48 -> { _7 }
i_49 -> { i_8 }
_50 -> { _9 }
fib_I_lsm0.41_51 -> { fib_I_lsm0.41_38 }
_52 -> { _10 }
_53 -> { _11 }
_54 -> { _12 }
.MEM_55 -> { .MEM_13 }
ivtmp_56 -> { ivtmp_25 }
Incremental SSA update started at block: 8
Number of blocks in CFG: 17
Number of blocks to update: 6 ( 35%)
Affected blocks: 3 10 11 13 14 15


Merging blocks 2 and 8
Merging blocks 3 and 4
Removing basic block 11
basic block 11, loop depth 1
 pred:      
 succ:       13


Merging blocks 2 and 9
Merging blocks 3 and 13
Merging blocks 3 and 14
count_averages ()
{
  long int fib_I_lsm1.42;
  long int fib_I_lsm0.41;
  int i;
  long int _1;
  long int _2;
  int _4;
  long int _5;
  unsigned int ivtmp_6;
  long int _7;
  long int _9;
  long int _10;
  long int _11;
  int _12;
  long int _14;
  long int _18;
  long int _19;
  int _20;
  unsigned int ivtmp_21;
  long int prephitmp_22;
  unsigned int ivtmp_25;
  unsigned int ivtmp_26;
  long int pretmp_28;
  long int prephitmp_29;
  int _30;
  long int _34;
  unsigned int ivtmp_35;
  long int _39;
  long int prephitmp_45;
  int _46;
  long int _47;
  long int _48;
  long int _50;
  long int _52;
  long int _53;
  int _54;
  unsigned int ivtmp_56;
  unsigned int ivtmp_57;
  unsigned int ivtmp_58;

  <bb 2>:
  pretmp_28 = fib[1];
  _39 = MEM[(long int *)&fib];

  <bb 3>:
  # i_16 = PHI <1(2), i_49(4)>
  # ivtmp_26 = PHI <998(2), ivtmp_56(4)>
  # fib_I_lsm0.41_36 = PHI <_39(2), fib_I_lsm0.41_38(4)>
  # fib_I_lsm1.42_37 = PHI <pretmp_28(2), fib_I_lsm1.42_51(4)>
  # ivtmp_57 = PHI <997(2), ivtmp_58(4)>
  prephitmp_29 = fib_I_lsm1.42_37;
  _4 = i_16 + -1;
  _5 = fib_I_lsm0.41_36;
  _7 = _5 + prephitmp_29;
  i_8 = i_16 + 1;
  _9 = fib[i_8];
  fib_I_lsm0.41_38 = _9;
  _10 = _7 + _9;
  _11 = _10 / 3;
  _12 = _11 & 65535;
  avg[i_16] = _12;
  ivtmp_25 = ivtmp_26 - 1;
  prephitmp_45 = fib_I_lsm0.41_38;
  _46 = i_8 + -1;
  _47 = fib_I_lsm1.42_37;
  _48 = _47 + prephitmp_45;
  i_49 = i_8 + 1;
  _50 = fib[i_49];
  fib_I_lsm1.42_51 = _50;
  _52 = _48 + _50;
  _53 = _52 / 3;
  _54 = _53 & 65535;
  avg[i_8] = _54;
  ivtmp_56 = ivtmp_25 + 4294967295;
  ivtmp_58 = ivtmp_57 - 2;
  if (ivtmp_58 > 1)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:
  # i_32 = PHI <i_49(3)>
  # _34 = PHI <_50(3)>
  # ivtmp_35 = PHI <ivtmp_56(3)>

  <bb 6>:
  # i_24 = PHI <i_32(5), i_15(7)>
  # prephitmp_22 = PHI <_34(5), _14(7)>
  # ivtmp_21 = PHI <ivtmp_35(5), ivtmp_6(7)>
  _20 = i_24 + -1;
  _19 = fib[_20];
  _18 = _19 + prephitmp_22;
  i_15 = i_24 + 1;
  _14 = fib[i_15];
  _2 = _18 + _14;
  _1 = _2 / 3;
  _30 = _1 & 65535;
  avg[i_24] = _30;
  ivtmp_6 = ivtmp_21 - 1;
  if (ivtmp_6 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  return;

}


