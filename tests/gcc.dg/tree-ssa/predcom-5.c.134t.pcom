
;; Function main (main, funcdef_no=0, decl_uid=1460, cgraph_uid=0, symbol_order=4) (executed once)

Processing loop 1
Creating dr for d[i_44]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: d
	Access function 0: {0, +, 1}_1
Creating dr for b[i_44]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {0, +, 1}_1
Creating dr for a[i_44]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {0, +, 1}_1
(compute_affine_dependence
  stmt_a: d[i_44] = i_44;
  stmt_b: b[i_44] = i_44;
) -> no dependence
(compute_affine_dependence
  stmt_a: d[i_44] = i_44;
  stmt_b: a[i_44] = i_44;
) -> no dependence
(compute_affine_dependence
  stmt_a: b[i_44] = i_44;
  stmt_b: a[i_44] = i_44;
) -> no dependence
(compute_affine_dependence
  stmt_a: d[i_44] = i_44;
  stmt_b: d[i_44] = i_44;
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: b[i_44] = i_44;
  stmt_b: b[i_44] = i_44;
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: a[i_44] = i_44;
  stmt_b: a[i_44] = i_44;
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_1)
  (chrec_b = {0, +, 1}_1)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: d[i_44] = i_44;
#  ref: d[i_44];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_44] = i_44;
#  ref: b[i_44];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: d[i_44] = i_44;
#  ref: d[i_44];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_44] = i_44;
#  ref: a[i_44];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_44] = i_44;
#  ref: b[i_44];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_44] = i_44;
#  ref: a[i_44];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: d[i_44] = i_44;
#  ref: d[i_44];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: d[i_44] = i_44;
#  ref: d[i_44];
#  base_object: d;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_44] = i_44;
#  ref: b[i_44];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: b[i_44] = i_44;
#  ref: b[i_44];
#  base_object: b;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_44] = i_44;
#  ref: a[i_44];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
#(Data Ref: 
#  bb: 3 
#  stmt: a[i_44] = i_44;
#  ref: a[i_44];
#  base_object: a;
#  Access function 0: {0, +, 1}_1
#)
  access_fn_A: {0, +, 1}_1
  access_fn_B: {0, +, 1}_1

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (1 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    a[i_44] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    b[i_44] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    d[i_44] (id 0, write)
      offset 0
      distance 0

Predictive commoning failed: no suitable chains
Processing loop 2
Creating dr for d[i_13]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: d
	Access function 0: {2, +, 1}_2
Creating dr for a[_15]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 12
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {3, +, 1}_2
Creating dr for b[i_13]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 8
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {2, +, 1}_2
Creating dr for b[_20]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {0, +, 1}_2
Creating dr for a[i_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {1, +, 1}_2
Creating dr for d[_20]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: d
	Access function 0: {0, +, 1}_2
Creating dr for c[i_45]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &c
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: c
	Access function 0: {1, +, 1}_2
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _16 = a[_15];
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _18 = b[i_13];
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _21 = b[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _22 = a[i_45];
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _24 = d[_20];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [2 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [2 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: _18 = b[i_13];
) -> no dependence
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: _21 = b[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: _22 = a[i_45];
(analyze_overlapping_iterations 
  (chrec_a = {3, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [2 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [2 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {3, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: _24 = d[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _18 = b[i_13];
  stmt_b: _21 = b[_20];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [0 + 1 * x_1])
  (overlaps_b = [2 + 1 * x_1]))
)
  (overlap_iterations_a = [0 + 1 * x_1])
  (overlap_iterations_b = [2 + 1 * x_1]))
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
(analyze_siv_subscript 
(analyze_subscript_affine_affine 
  (overlaps_a = [2 + 1 * x_1])
  (overlaps_b = [0 + 1 * x_1]))
)
  (overlap_iterations_a = [2 + 1 * x_1])
  (overlap_iterations_b = [0 + 1 * x_1]))
(build_classic_dist_vector
  dist_vector = (  2 
  )
)
)
(compute_affine_dependence
  stmt_a: _18 = b[i_13];
  stmt_b: _22 = a[i_45];
) -> no dependence
(compute_affine_dependence
  stmt_a: _18 = b[i_13];
  stmt_b: _24 = d[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _18 = b[i_13];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _21 = b[_20];
  stmt_b: _22 = a[i_45];
) -> no dependence
(compute_affine_dependence
  stmt_a: _21 = b[_20];
  stmt_b: _24 = d[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _21 = b[_20];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _22 = a[i_45];
  stmt_b: _24 = d[_20];
) -> no dependence
(compute_affine_dependence
  stmt_a: _22 = a[i_45];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _24 = d[_20];
  stmt_b: c[i_45] = _26;
) -> no dependence
(compute_affine_dependence
  stmt_a: _14 = d[i_13];
  stmt_b: _14 = d[i_13];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _16 = a[_15];
  stmt_b: _16 = a[_15];
(analyze_overlapping_iterations 
  (chrec_a = {3, +, 1}_2)
  (chrec_b = {3, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _18 = b[i_13];
  stmt_b: _18 = b[i_13];
(analyze_overlapping_iterations 
  (chrec_a = {2, +, 1}_2)
  (chrec_b = {2, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _21 = b[_20];
  stmt_b: _21 = b[_20];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _22 = a[i_45];
  stmt_b: _22 = a[i_45];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: _24 = d[_20];
  stmt_b: _24 = d[_20];
(analyze_overlapping_iterations 
  (chrec_a = {0, +, 1}_2)
  (chrec_b = {0, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(compute_affine_dependence
  stmt_a: c[i_45] = _26;
  stmt_b: c[i_45] = _26;
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_2)
  (chrec_b = {1, +, 1}_2)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 995
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 995
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {3, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 995
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 995
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [2 + 1 * x_1]
  last_conflict: 995
  iterations_that_access_an_element_twice_in_B: [0 + 1 * x_1]
  last_conflict: 995
  (Subscript distance: 2 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   2 
  direction_vector:     +
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
    (no dependence)
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _14 = d[i_13];
#  ref: d[i_13];
#  base_object: d;
#  Access function 0: {2, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {2, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _16 = a[_15];
#  ref: a[_15];
#  base_object: a;
#  Access function 0: {3, +, 1}_2
#)
  access_fn_A: {3, +, 1}_2
  access_fn_B: {3, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _18 = b[i_13];
#  ref: b[i_13];
#  base_object: b;
#  Access function 0: {2, +, 1}_2
#)
  access_fn_A: {2, +, 1}_2
  access_fn_B: {2, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _21 = b[_20];
#  ref: b[_20];
#  base_object: b;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {0, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _22 = a[i_45];
#  ref: a[i_45];
#  base_object: a;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {1, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: _24 = d[_20];
#  ref: d[_20];
#  base_object: d;
#  Access function 0: {0, +, 1}_2
#)
  access_fn_A: {0, +, 1}_2
  access_fn_B: {0, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
(Data Dep: 
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
#(Data Ref: 
#  bb: 6 
#  stmt: c[i_45] = _26;
#  ref: c[i_45];
#  base_object: c;
#  Access function 0: {1, +, 1}_2
#)
  access_fn_A: {1, +, 1}_2
  access_fn_B: {1, +, 1}_2

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (2 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    c[i_45] (id 0, write)
      offset 0
      distance 0

Component (invariant):
    b[i_13] (id 0)
      offset 0
      distance 0
    b[_20] (id 1)
      offset 0
      distance 0

Component (invariant):
    a[_15] (id 0)
      offset 0
      distance 0
    a[i_45] (id 1)
      offset 0
      distance 0

Component (invariant):
    d[i_13] (id 0)
      offset 0
      distance 0
    d[_20] (id 1)
      offset 0
      distance 0

Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
Before commoning:

Loads-only chain 0x100f16210 (combined)
  max distance 2
  inits MEM[(unsigned int *)&b] MEM[(unsigned int *)&b + 4B]
  references:
    b[i_13] (id 0)
      offset 0
      distance 0
    b[_20] (id 1)
      offset 2
      distance 2

Loads-only chain 0x100f17de0 (combined)
  max distance 2
  inits MEM[(unsigned int *)&a + 4B] MEM[(unsigned int *)&a + 8B]
  references:
    a[_15] (id 0)
      offset 0
      distance 0
    a[i_45] (id 1)
      offset 2
      distance 2

Loads-only chain 0x100f17ef0 (combined)
  max distance 2
  inits MEM[(unsigned int *)&d] MEM[(unsigned int *)&d + 4B]
  references:
    d[i_13] (id 0)
      offset 0
      distance 0
    d[_20] (id 1)
      offset 2
      distance 2

Combination chain 0x100f17f70 (combined)
  max distance 2
  equal to 0x100f17ef0 * 0x100f16210 in type unsigned int
  references:
    combination ref
      in statement predreastmp.3_59 = _14 * _18;

      distance 0
    combination ref
      in statement _31 = _21 * _24;

      distance 2

Combination chain 0x100f16f50
  max distance 2
  equal to 0x100f17f70 * 0x100f17de0 in type unsigned int
  references:
    combination ref
      in statement _19 = predreastmp.3_59 * predreastmp.4_58;

      distance 0
    combination ref
      in statement _25 = _22 * _31;

      distance 2

Analyzing # of iterations of loop 2
  exit condition [996, + , 4294967295] != 0
  bounds on difference of bases: -996 ... -996
  result:
    # of iterations 996, bounded by 996
Unrolling 3 times.

Updating SSA:
creating PHI node in block #8 for .MEM_27
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #6
Updating SSA information for statement i_13 = i_45 + 1;
Updating SSA information for statement _14 = d[i_13];
Updating SSA information for statement _15 = i_45 + 2;
Updating SSA information for statement _16 = a[_15];
Updating SSA information for statement _17 = _16;
Updating SSA information for statement _18 = b[i_13];
Updating SSA information for statement predreastmp.3_59 = _14 * _18;
Updating SSA information for statement predreastmp.4_58 = _17;
Updating SSA information for statement _19 = predreastmp.3_59 * predreastmp.4_58;
Updating SSA information for statement _20 = i_45 + 4294967295;
Updating SSA information for statement _21 = b[_20];
Updating SSA information for statement _22 = a[i_45];
Updating SSA information for statement _24 = d[_20];
Updating SSA information for statement _31 = _21 * _24;
Updating SSA information for statement _25 = _22 * _31;
Updating SSA information for statement _26 = _19 - _25;
Updating SSA information for statement c[i_45] = _26;
Updating SSA information for statement ivtmp_62 = ivtmp_63 - 1;
Updating SSA information for statement if (ivtmp_62 != 0)
Registering new PHI nodes in block #7
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Updating SSA information for statement i_54 = i_45 + 1;
Updating SSA information for statement _53 = d[i_13];
Updating SSA information for statement _52 = i_45 + 2;
Updating SSA information for statement _51 = a[_15];
Updating SSA information for statement _50 = _16;
Updating SSA information for statement _49 = b[i_13];
Updating SSA information for statement predreastmp.3_43 = _14 * _18;
Updating SSA information for statement predreastmp.4_42 = _17;
Updating SSA information for statement _41 = predreastmp.3_59 * predreastmp.4_58;
Updating SSA information for statement _39 = i_45 + 4294967295;
Updating SSA information for statement _38 = b[_20];
Updating SSA information for statement _23 = a[i_45];
Updating SSA information for statement _10 = d[_20];
Updating SSA information for statement _8 = _21 * _24;
Updating SSA information for statement _5 = _22 * _31;
Updating SSA information for statement _4 = _19 - _25;
Updating SSA information for statement c[i_45] = _26;
Updating SSA information for statement ivtmp_2 = ivtmp_63 - 1;
Updating SSA information for statement if (ivtmp_62 != 0)
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _28 = c[i_46];
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Updating SSA information for statement return 0;
Registering new PHI nodes in block #10
Updating SSA information for statement abort ();

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

.MEM_1 -> { .MEM_27 }
ivtmp_2 -> { ivtmp_62 }
.MEM_3 -> { .MEM_27 }
_4 -> { _26 }
_5 -> { _25 }
_8 -> { _31 }
_10 -> { _24 }
_23 -> { _22 }
_38 -> { _21 }
_39 -> { _20 }
_41 -> { _19 }
predreastmp.4_42 -> { predreastmp.4_58 }
predreastmp.3_43 -> { predreastmp.3_59 }
_49 -> { _18 }
_50 -> { _17 }
_51 -> { _16 }
_52 -> { _15 }
_53 -> { _14 }
i_54 -> { i_13 }
ivtmp_55 -> { ivtmp_63 }
.MEM_56 -> { .MEM_48 }
i_57 -> { i_45 }
Incremental SSA update started at block: 16
Number of blocks in CFG: 19
Number of blocks to update: 10 ( 53%)
Affected blocks: 6 7 8 9 10 13 14 15 17 18


Removing basic block 20
basic block 20, loop depth 0
 pred:      
 succ:       8


gimple_simplified to _69 = _70 * _71;
gimple_simplified to _67 = _68 * _69;

Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #3
Updating SSA information for statement d[i_44] = i_44;
Updating SSA information for statement b[i_44] = i_44;
Updating SSA information for statement a[i_44] = i_44;
Registering new PHI nodes in block #4
Registering new PHI nodes in block #5
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Updating SSA information for statement _71 = MEM[(unsigned int *)&d];
Updating SSA information for statement _70 = MEM[(unsigned int *)&b];
Updating SSA information for statement _68 = MEM[(unsigned int *)&a + 4B];
Updating SSA information for statement _66 = MEM[(unsigned int *)&d + 4B];
Updating SSA information for statement _78 = MEM[(unsigned int *)&b + 4B];
Updating SSA information for statement _80 = MEM[(unsigned int *)&a + 8B];
Registering new PHI nodes in block #6
Updating SSA information for statement _14 = d[i_13];
Updating SSA information for statement _16 = a[_15];
Updating SSA information for statement _18 = b[i_13];
Updating SSA information for statement c[i_45] = _26;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #19
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Updating SSA information for statement _53 = d[i_54];
Updating SSA information for statement _51 = a[_52];
Updating SSA information for statement _49 = b[i_54];
Updating SSA information for statement _38 = b[_39];
Updating SSA information for statement _23 = a[i_57];
Updating SSA information for statement _10 = d[_39];
Updating SSA information for statement c[i_57] = _4;
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Updating SSA information for statement _28 = c[i_46];
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Updating SSA information for statement return 0;
Registering new PHI nodes in block #10
Updating SSA information for statement abort ();

Symbols to be put in SSA form
{ D.1499 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 21
Number of blocks to update: 19 ( 90%)
Affected blocks: 0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19


Removing basic block 27
basic block 27, loop depth 0
 pred:      
 succ:       18


Removing basic block 28
basic block 28, loop depth 0
 pred:      
 succ:       18



Updating SSA:
Registering new PHI nodes in block #16
Registering new PHI nodes in block #17
Registering new PHI nodes in block #6
Updating SSA information for statement i_13 = i_45 + 1;
Updating SSA information for statement _14 = d[i_13];
Updating SSA information for statement _15 = i_45 + 2;
Updating SSA information for statement _16 = a[_15];
Updating SSA information for statement _17 = _16;
Updating SSA information for statement _18 = b[i_13];
Updating SSA information for statement predreastmp.3_59 = _14 * _18;
Updating SSA information for statement predreastmp.4_58 = _17;
Updating SSA information for statement _19 = predreastmp.3_59 * predreastmp.4_58;
Updating SSA information for statement D_lsm2.7_72 = _19;
Updating SSA information for statement _20 = i_45 + 4294967295;
Updating SSA information for statement _25 = D_lsm0.5_74;
Updating SSA information for statement _26 = _19 - _25;
Updating SSA information for statement c[i_45] = _26;
Updating SSA information for statement ivtmp_62 = ivtmp_63 - 1;
Registering new PHI nodes in block #7
Registering new PHI nodes in block #19
Registering new PHI nodes in block #21
Updating SSA information for statement i_83 = i_45 + 1;
Updating SSA information for statement _84 = d[i_13];
Updating SSA information for statement _85 = i_45 + 2;
Updating SSA information for statement _86 = a[_15];
Updating SSA information for statement _87 = _16;
Updating SSA information for statement _88 = b[i_13];
Updating SSA information for statement predreastmp.3_89 = _14 * _18;
Updating SSA information for statement predreastmp.4_90 = _17;
Updating SSA information for statement _91 = predreastmp.3_59 * predreastmp.4_58;
Updating SSA information for statement D_lsm2.7_92 = _19;
Updating SSA information for statement _93 = i_45 + 4294967295;
Updating SSA information for statement _94 = D_lsm0.5_74;
Updating SSA information for statement _95 = _19 - _25;
Updating SSA information for statement c[i_45] = _26;
Updating SSA information for statement ivtmp_97 = ivtmp_63 - 1;
Registering new PHI nodes in block #22
Registering new PHI nodes in block #23
Registering new PHI nodes in block #24
Updating SSA information for statement i_103 = i_45 + 1;
Updating SSA information for statement _104 = d[i_13];
Updating SSA information for statement _105 = i_45 + 2;
Updating SSA information for statement _106 = a[_15];
Updating SSA information for statement _107 = _16;
Updating SSA information for statement _108 = b[i_13];
Updating SSA information for statement predreastmp.3_109 = _14 * _18;
Updating SSA information for statement predreastmp.4_110 = _17;
Updating SSA information for statement _111 = predreastmp.3_59 * predreastmp.4_58;
Updating SSA information for statement D_lsm2.7_112 = _19;
Updating SSA information for statement _113 = i_45 + 4294967295;
Updating SSA information for statement _114 = D_lsm0.5_74;
Updating SSA information for statement _115 = _19 - _25;
Updating SSA information for statement c[i_45] = _26;
Updating SSA information for statement ivtmp_117 = ivtmp_63 - 1;
Registering new PHI nodes in block #25
Registering new PHI nodes in block #26
Registering new PHI nodes in block #18
Registering new PHI nodes in block #14
Registering new PHI nodes in block #15
Registering new PHI nodes in block #8
Registering new PHI nodes in block #9
Registering new PHI nodes in block #11
Registering new PHI nodes in block #12
Registering new PHI nodes in block #13
Registering new PHI nodes in block #10

SSA replacement table
N_i -> { O_1 ... O_j } means that N_i replaces O_1, ..., O_j

D_lsm0.5_21 -> { D_lsm0.5_74 }
ivtmp_22 -> { ivtmp_63 }
.MEM_24 -> { .MEM_48 }
i_31 -> { i_45 }
D_lsm1.6_82 -> { D_lsm1.6_73 }
i_83 -> { i_13 }
_84 -> { _14 }
_85 -> { _15 }
_86 -> { _16 }
_87 -> { _17 }
_88 -> { _18 }
predreastmp.3_89 -> { predreastmp.3_59 }
predreastmp.4_90 -> { predreastmp.4_58 }
_91 -> { _19 }
D_lsm2.7_92 -> { D_lsm2.7_72 }
_93 -> { _20 }
_94 -> { _25 }
_95 -> { _26 }
.MEM_96 -> { .MEM_27 }
ivtmp_97 -> { ivtmp_62 }
i_98 -> { i_45 }
.MEM_99 -> { .MEM_48 }
ivtmp_100 -> { ivtmp_63 }
D_lsm0.5_101 -> { D_lsm0.5_74 }
D_lsm1.6_102 -> { D_lsm1.6_73 }
i_103 -> { i_13 }
_104 -> { _14 }
_105 -> { _15 }
_106 -> { _16 }
_107 -> { _17 }
_108 -> { _18 }
predreastmp.3_109 -> { predreastmp.3_59 }
predreastmp.4_110 -> { predreastmp.4_58 }
_111 -> { _19 }
D_lsm2.7_112 -> { D_lsm2.7_72 }
_113 -> { _20 }
_114 -> { _25 }
_115 -> { _26 }
.MEM_116 -> { .MEM_27 }
ivtmp_117 -> { ivtmp_62 }
Incremental SSA update started at block: 16
Number of blocks in CFG: 29
Number of blocks to update: 8 ( 28%)
Affected blocks: 6 18 19 21 23 24 25 26


Processing loop 3
Creating dr for c[i_46]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &c
	offset from base address: 0
	constant offset from base address: 4
	step: 4
	aligned to: 32
	base_object: c
	Access function 0: {1, +, 1}_3
(compute_affine_dependence
  stmt_a: _28 = c[i_46];
  stmt_b: _28 = c[i_46];
(analyze_overlapping_iterations 
  (chrec_a = {1, +, 1}_3)
  (chrec_b = {1, +, 1}_3)
  (overlap_iterations_a = [0])
  (overlap_iterations_b = [0]))
)
(Data Dep: 
#(Data Ref: 
#  bb: 9 
#  stmt: _28 = c[i_46];
#  ref: c[i_46];
#  base_object: c;
#  Access function 0: {1, +, 1}_3
#)
#(Data Ref: 
#  bb: 9 
#  stmt: _28 = c[i_46];
#  ref: c[i_46];
#  base_object: c;
#  Access function 0: {1, +, 1}_3
#)
  access_fn_A: {1, +, 1}_3
  access_fn_B: {1, +, 1}_3

 (subscript 
  iterations_that_access_an_element_twice_in_A: [0]
  last_conflict: scev_not_known
  iterations_that_access_an_element_twice_in_B: [0]
  last_conflict: scev_not_known
  (Subscript distance: 0 ))
  inner loop index: 0
  loop nest: (3 )
  distance_vector:   0 
  direction_vector:     =
)
Initial state:

Component (invariant):
    c[i_46] (id 0)
      offset 0
      distance 0

Predictive commoning failed: no suitable chains
Removing basic block 5
basic block 5, loop depth 0
 pred:      
 succ:       16


Merging blocks 6 and 7
Removing basic block 16
basic block 16, loop depth 0
 pred:      
 succ:       17


Removing basic block 19
basic block 19, loop depth 1
 pred:      
 succ:       21


Removing basic block 22
basic block 22, loop depth 1
 pred:      
 succ:       23


Removing basic block 23
basic block 23, loop depth 1
 pred:      
 succ:       24


Merging blocks 6 and 21
Merging blocks 6 and 24
Merging blocks 6 and 25
main ()
{
  unsigned int D_lsm2.7;
  unsigned int D_lsm1.6;
  unsigned int D_lsm0.5;
  unsigned int predreastmp.4;
  unsigned int predreastmp.3;
  unsigned int i;
  unsigned int ivtmp_2;
  unsigned int _4;
  unsigned int _5;
  unsigned int _8;
  unsigned int _10;
  unsigned int _14;
  unsigned int _15;
  unsigned int _16;
  unsigned int _17;
  unsigned int _18;
  unsigned int _19;
  unsigned int _20;
  unsigned int _23;
  unsigned int _25;
  unsigned int _26;
  unsigned int _28;
  unsigned int _30;
  unsigned int _32;
  unsigned int _33;
  unsigned int _34;
  unsigned int _35;
  unsigned int _36;
  unsigned int _38;
  unsigned int _39;
  unsigned int _40;
  unsigned int _41;
  unsigned int _49;
  unsigned int _50;
  unsigned int _51;
  unsigned int _52;
  unsigned int _53;
  unsigned int ivtmp_55;
  unsigned int ivtmp_60;
  unsigned int ivtmp_61;
  unsigned int ivtmp_62;
  unsigned int ivtmp_63;
  unsigned int ivtmp_64;
  unsigned int ivtmp_65;
  unsigned int _66;
  unsigned int _67;
  unsigned int _68;
  unsigned int _69;
  unsigned int _70;
  unsigned int _71;
  unsigned int ivtmp_75;
  unsigned int _78;
  unsigned int _79;
  unsigned int _80;
  unsigned int _81;
  unsigned int _84;
  unsigned int _85;
  unsigned int _86;
  unsigned int _87;
  unsigned int _88;
  unsigned int _91;
  unsigned int _93;
  unsigned int _94;
  unsigned int _95;
  unsigned int ivtmp_97;
  unsigned int _104;
  unsigned int _105;
  unsigned int _106;
  unsigned int _107;
  unsigned int _108;
  unsigned int _111;
  unsigned int _113;
  unsigned int _114;
  unsigned int _115;
  unsigned int ivtmp_117;
  unsigned int ivtmp_118;
  unsigned int ivtmp_119;

  <bb 2>:

  <bb 3>:
  # i_44 = PHI <i_12(4), 0(2)>
  # ivtmp_61 = PHI <ivtmp_60(4), 1000(2)>
  d[i_44] = i_44;
  b[i_44] = i_44;
  a[i_44] = i_44;
  i_12 = i_44 + 1;
  ivtmp_60 = ivtmp_61 - 1;
  if (ivtmp_60 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:
  _71 = MEM[(unsigned int *)&d];
  _70 = MEM[(unsigned int *)&b];
  _69 = _70 * _71;
  _68 = MEM[(unsigned int *)&a + 4B];
  _67 = _68 * _69;
  _66 = MEM[(unsigned int *)&d + 4B];
  _78 = MEM[(unsigned int *)&b + 4B];
  _79 = _66 * _78;
  _80 = MEM[(unsigned int *)&a + 8B];
  _81 = _79 * _80;

  <bb 6>:
  # i_45 = PHI <1(5), i_103(7)>
  # ivtmp_63 = PHI <997(5), ivtmp_117(7)>
  # D_lsm0.5_74 = PHI <_67(5), D_lsm0.5_92(7)>
  # D_lsm1.6_73 = PHI <_81(5), D_lsm1.6_112(7)>
  # ivtmp_118 = PHI <996(5), ivtmp_119(7)>
  i_13 = i_45 + 1;
  _14 = d[i_13];
  _15 = i_45 + 2;
  _16 = a[_15];
  _17 = _16;
  _18 = b[i_13];
  predreastmp.3_59 = _14 * _18;
  predreastmp.4_58 = _17;
  _19 = predreastmp.3_59 * predreastmp.4_58;
  D_lsm2.7_72 = _19;
  _20 = i_45 + 4294967295;
  _25 = D_lsm0.5_74;
  _26 = _19 - _25;
  c[i_45] = _26;
  ivtmp_62 = ivtmp_63 - 1;
  i_83 = i_13 + 1;
  _84 = d[i_83];
  _85 = i_13 + 2;
  _86 = a[_85];
  _87 = _86;
  _88 = b[i_83];
  predreastmp.3_89 = _84 * _88;
  predreastmp.4_90 = _87;
  _91 = predreastmp.3_89 * predreastmp.4_90;
  D_lsm0.5_92 = _91;
  _93 = i_13 + 4294967295;
  _94 = D_lsm1.6_73;
  _95 = _91 - _94;
  c[i_13] = _95;
  ivtmp_97 = ivtmp_62 + 4294967295;
  i_103 = i_83 + 1;
  _104 = d[i_103];
  _105 = i_83 + 2;
  _106 = a[_105];
  _107 = _106;
  _108 = b[i_103];
  predreastmp.3_109 = _104 * _108;
  predreastmp.4_110 = _107;
  _111 = predreastmp.3_109 * predreastmp.4_110;
  D_lsm1.6_112 = _111;
  _113 = i_83 + 4294967295;
  _114 = D_lsm2.7_72;
  _115 = _111 - _114;
  c[i_83] = _115;
  ivtmp_117 = ivtmp_97 + 4294967295;
  ivtmp_119 = ivtmp_118 - 3;
  if (ivtmp_119 > 2)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  # i_77 = PHI <i_103(6)>
  # ivtmp_75 = PHI <ivtmp_117(6)>

  <bb 9>:
  # i_57 = PHI <i_77(8), i_54(10)>
  # ivtmp_55 = PHI <ivtmp_75(8), ivtmp_2(10)>
  i_54 = i_57 + 1;
  _53 = d[i_54];
  _52 = i_57 + 2;
  _51 = a[_52];
  _50 = _51;
  _49 = b[i_54];
  predreastmp.3_43 = _53 * _49;
  predreastmp.4_42 = _50;
  _41 = predreastmp.3_43 * predreastmp.4_42;
  _39 = i_57 + 4294967295;
  _38 = b[_39];
  _23 = a[i_57];
  _10 = d[_39];
  _8 = _38 * _10;
  _5 = _23 * _8;
  _4 = _41 - _5;
  c[i_57] = _4;
  ivtmp_2 = ivtmp_55 - 1;
  if (ivtmp_2 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 9>;

  <bb 11>:

  <bb 12>:
  # i_46 = PHI <1(11), i_29(15)>
  # ivtmp_65 = PHI <997(11), ivtmp_64(15)>
  _28 = c[i_46];
  i_29 = i_46 + 1;
  _30 = i_46 + 2;
  _34 = i_29 * i_29;
  _32 = _30 * _34;
  _33 = i_46 + 4294967295;
  _40 = _33 * _33;
  _35 = _40 * i_46;
  _36 = _32 - _35;
  if (_28 != _36)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  abort ();

  <bb 14>:
  ivtmp_64 = ivtmp_65 - 1;
  if (ivtmp_64 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  goto <bb 12>;

  <bb 16>:
  return 0;

}


