
;; Function foo (foo, funcdef_no=0, decl_uid=1460, cgraph_uid=0, symbol_order=4)

Creating dr for a[i_14]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {0, +, 1}_1
Creating dr for a[i_14]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {0, +, 1}_1
Creating dr for d[i_14]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: d
	Access function 0: {0, +, 1}_1
Creating dr for b[i_14]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &b
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: b
	Access function 0: {0, +, 1}_1
Creating dr for c[i_14]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &c
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: c
	Access function 0: {0, +, 1}_1
(rdg
(vertex 0: () (in: 9 8) (out: 3 5 7 1 4 8)
i_14 = PHI <i_11(4), 0(2)>
)
(vertex 1: (r) (in: 9 0) (out: 2)
# VUSE <.MEM_15>
_4 = a[i_14];
)
(vertex 2: () (in: 9 1) (out: 3 6)
_5 = _4 + 1;
)
(vertex 3: (w) (in: 9 2 0) (out:)
# .MEM_6 = VDEF <.MEM_15>
a[i_14] = _5;
)
(vertex 4: (r) (in: 9 0) (out: 5 6)
# VUSE <.MEM_6>
_7 = d[i_14];
)
(vertex 5: (w) (in: 9 4 0) (out:)
# .MEM_8 = VDEF <.MEM_6>
b[i_14] = _7;
)
(vertex 6: () (in: 9 4 2) (out: 7)
_9 = _5 / _7;
)
(vertex 7: (w) (in: 9 6 0) (out:)
# .MEM_10 = VDEF <.MEM_8>
c[i_14] = _9;
)
(vertex 8: () (in: 9 0) (out: 9 0)
i_11 = i_14 + 1;
)
(vertex 9: () (in: 9 8) (out: 9 8 7 6 5 4 3 2 1 0)
if (i_11 != 128)
)
)
ldist asked to generate code for vertex 3
ldist useful partition:
0, 1, 2, 3, 8, 9
ldist asked to generate code for vertex 5
ldist useful partition:
0, 4, 5, 8, 9
ldist asked to generate code for vertex 7
ldist useful partition:
0, 1, 2, 4, 6, 7, 8, 9
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 128
  bounds on difference of bases: 127 ... 127
  result:
    # of iterations 127, bounded by 127
(compute_affine_dependence
  stmt_a: _7 = d[i_14];
  stmt_b: b[i_14] = _7;
) -> no dependence
fusing non-builtin partitions
0, 1, 2, 3, 8, 9
0, 1, 2, 4, 6, 7, 8, 9
(compute_affine_dependence
  stmt_a: a[i_14] = _5;
  stmt_b: _7 = d[i_14];
) -> no dependence
(compute_affine_dependence
  stmt_a: _7 = d[i_14];
  stmt_b: c[i_14] = _9;
) -> no dependence
(compute_affine_dependence
  stmt_a: _4 = a[i_14];
  stmt_b: b[i_14] = _7;
) -> no dependence
(compute_affine_dependence
  stmt_a: _7 = d[i_14];
  stmt_b: b[i_14] = _7;
) -> no dependence
(compute_affine_dependence
  stmt_a: a[i_14] = _5;
  stmt_b: b[i_14] = _7;
) -> no dependence
(compute_affine_dependence
  stmt_a: b[i_14] = _7;
  stmt_b: c[i_14] = _9;
) -> no dependence

first = 0x1010020e0 current = 0x1010020e0 indx = 0
	0x1010020e0 next = 0x0 prev = 0x0 indx = 0
		bits = { 0 1 2 3 4 6 7 8 9 }

first = 0x1010020b8 current = 0x1010020b8 indx = 0
	0x1010020b8 next = 0x0 prev = 0x0 indx = 0
		bits = { 0 4 5 8 9 }
Removing basic block 9
basic block 9, loop depth 0
 pred:       2
 succ:      


Applying pattern match.pd:49, generic-match.c:4015
Applying pattern match.pd:49, generic-match.c:4015
generated memcpy
Marking result for renaming : .MEM_15 = PHI <.MEM_10(4), .MEM_3(D)(6)>

Removing basic block 3
basic block 3, loop depth 0
 pred:       4
             6
# i_14 = PHI <i_11(4), 0(6)>
_4 = a[i_14];
_5 = _4 + 1;
a[i_14] = _5;
_7 = d[i_14];
b[i_14] = _7;
_9 = _5 / _7;
c[i_14] = _9;
i_11 = i_14 + 1;
if (i_11 != 128)
 succ:       4


Removing basic block 4
basic block 4, loop depth 0
 pred:      
 succ:      


ldist-23.c:12:3: note: Loop 1 distributed: split to 1 loops and 1 library calls.

Updating SSA:
Registering new PHI nodes in block #0
Registering new PHI nodes in block #2
Registering new PHI nodes in block #7
Updating SSA information for statement _13 = a[i_17];
Updating SSA information for statement a[i_17] = _12;
Updating SSA information for statement _1 = d[i_17];
Updating SSA information for statement c[i_17] = _19;
Registering new PHI nodes in block #8
Registering new PHI nodes in block #10
Registering new PHI nodes in block #6
Updating SSA information for statement __builtin_memcpy (&b, &d, 512);
Registering new PHI nodes in block #5
Updating SSA information for statement return;

Symbols to be put in SSA form
{ D.1485 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 11
Number of blocks to update: 7 ( 64%)
Affected blocks: 0 2 5 6 7 8 10


foo ()
{
  int i;
  int _1;
  int _12;
  int _13;
  int _19;

  <bb 2>:

  <bb 7>:
  # i_17 = PHI <i_21(8), 0(2)>
  _13 = a[i_17];
  _12 = _13 + 1;
  a[i_17] = _12;
  _1 = d[i_17];
  _19 = _12 / _1;
  c[i_17] = _19;
  i_21 = i_17 + 1;
  if (i_21 != 128)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  goto <bb 7>;

  <bb 10>:

  <bb 6>:
  __builtin_memcpy (&b, &d, 512);

  <bb 5>:
  return;

}



;; Function main (main, funcdef_no=1, decl_uid=1466, cgraph_uid=1, symbol_order=5) (executed once)

Creating dr for a[i_19]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &a
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: a
	Access function 0: {0, +, 1}_1
(rdg
(vertex 0: () (in: 3 2) (out: 1 1 2)
i_19 = PHI <i_8(4), 0(2)>
)
(vertex 1: (w) (in: 3 0 0) (out:)
# .MEM_7 = VDEF <.MEM_21>
a[i_19] = i_19;
)
(vertex 2: () (in: 3 0) (out: 3 0)
i_8 = i_19 + 1;
)
(vertex 3: () (in: 3 2) (out: 3 2 1 0)
if (i_8 != 128)
)
)
ldist asked to generate code for vertex 1
ldist useful partition:
0, 1, 2, 3
Analyzing # of iterations of loop 1
  exit condition [1, + , 1](no_overflow) != 128
  bounds on difference of bases: 127 ... 127
  result:
    # of iterations 127, bounded by 127
Loop 1 is the same.
Creating dr for d[i_20]
analyze_innermost: Applying pattern match.pd:49, generic-match.c:3223
success.
	base_address: &d
	offset from base address: 0
	constant offset from base address: 0
	step: 4
	aligned to: 32
	base_object: d
	Access function 0: {0, +, 1}_2
(rdg
(vertex 0: () (in: 3 2) (out: 1 2)
i_20 = PHI <0(5), i_10(7)>
)
(vertex 1: (w) (in: 3 0) (out:)
# .MEM_9 = VDEF <.MEM_22>
d[i_20] = 1;
)
(vertex 2: () (in: 3 0) (out: 3 0)
i_10 = i_20 + 1;
)
(vertex 3: () (in: 3 2) (out: 3 2 1 0)
if (i_10 != 128)
)
)
ldist asked to generate code for vertex 1
ldist useful partition:
0, 1, 2, 3
Analyzing # of iterations of loop 2
  exit condition [1, + , 1](no_overflow) != 128
  bounds on difference of bases: 127 ... 127
  result:
    # of iterations 127, bounded by 127
Loop 2 is the same.
main ()
{
  int i;
  int _12;

  <bb 2>:

  <bb 3>:
  # i_19 = PHI <i_8(4), 0(2)>
  a[i_19] = i_19;
  i_8 = i_19 + 1;
  if (i_8 != 128)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 3>;

  <bb 5>:

  <bb 6>:
  # i_20 = PHI <0(5), i_10(7)>
  d[i_20] = 1;
  i_10 = i_20 + 1;
  if (i_10 != 128)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 6>;

  <bb 8>:
  foo ();
  _12 = c[0];
  if (_12 != 1)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  abort ();

  <bb 10>:
  return 0;

}


