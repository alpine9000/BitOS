Symbol table:

abort/3 (abort) @0x142603640
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  First run: 0
  Function flags:
  Called by: main/2 
  Calls: 
main/2 (main) @0x1426034b0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: x/0 (write)
  Referring: 
  Availability: available
  First run: 0
  Function flags: body only_called_at_startup executed_once only_called_at_startup
  Called by: 
  Calls: abort/3 foo/1 (1.00 per call) 
foo/1 (foo) @0x142603320
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: x/0 (read)
  Referring: 
  Availability: local
  First run: 0
  Function flags: body local nonfreeing_fn executed_once
  Called by: main/2 (1.00 per call) 
  Calls: 
x/0 (x) @0x142700000
  Type: variable definition analyzed
  Visibility: externally_visible public common
  References: 
  Referring: foo/1 (read)main/2 (write)
  Availability: overwritable
  Varpool flags:


;; Function main (main, funcdef_no=1, decl_uid=1460, cgraph_uid=1, symbol_order=2) (executed once)

Modification phase of node main/2
main ()
{
  int * p;
  int b;
  int _5;

  <bb 2>:
  p = &b;
  x = &p;
  _5 = foo (&p);
  if (_5 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  b ={v} {CLOBBER};
  p ={v} {CLOBBER};
  return 0;

}



;; Function foo (foo, funcdef_no=0, decl_uid=1455, cgraph_uid=0, symbol_order=1) (executed once)

Modification phase of node foo/1
  Adjusting alignment of param 0 to 4, misalignment to 0
foo (int * * q)
{
  int a;
  int * _4;
  int * * x.0_6;
  int * _8;
  int _9;

  <bb 2>:
  a = 1;
  _4 = *q_3(D);
  *_4 = 0;
  x.0_6 = x;
  *x.0_6 = &a;
  _8 = *q_3(D);
  _9 = *_8;
  a ={v} {CLOBBER};
  return _9;

}


Generating constraints for global initializers

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
x = NONLOCAL

Generating constraints for main (main)

p = &b
x = &p
ESCAPED = &p
main.clobber = &x
foo.arg0 = &p
_5 = foo.result
main.use = &p
main.clobber = foo.clobber
main.use = foo.use
main.clobber = ESCAPED
main.use = ESCAPED
main.result = &NULL

Generating constraints for foo (foo)

a = &NONLOCAL
_4 = *foo.arg0
foo.use = foo.arg0
derefaddrtmp = &NULL
*_4 = derefaddrtmp
foo.clobber = _4
x.0_6 = x
foo.use = &x
derefaddrtmp = &a
*x.0_6 = derefaddrtmp
foo.clobber = x.0_6
_8 = *foo.arg0
foo.use = foo.arg0
_9 = *_8
foo.use = _8
foo.result = _9


Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Equivalence classes for indirect node id 1 "NULL": pointer 1, location 1
Equivalence classes for indirect node id 2 "ANYTHING": pointer 2, location 2
Equivalence classes for indirect node id 3 "STRING": pointer 3, location 0
Equivalence classes for indirect node id 4 "ESCAPED": pointer 6, location 3
Equivalence classes for indirect node id 5 "NONLOCAL": pointer 4, location 4
Equivalence classes for direct node id 6 "STOREDANYTHING": pointer 0, location 0
Equivalence classes for indirect node id 7 "INTEGER": pointer 7, location 0
Equivalence classes for direct node id 8 "main": pointer 0, location 0
Equivalence classes for direct node id 9 "main.clobber": pointer 11, location 0
Equivalence classes for direct node id 10 "main.use": pointer 14, location 0
Equivalence classes for direct node id 11 "main.result": pointer 15, location 0
Equivalence classes for direct node id 12 "main.varargs": pointer 0, location 0
Equivalence classes for direct node id 13 "foo": pointer 0, location 0
Equivalence classes for direct node id 14 "foo.clobber": pointer 10, location 0
Equivalence classes for direct node id 15 "foo.use": pointer 13, location 0
Equivalence classes for direct node id 16 "foo.result": pointer 16, location 0
Equivalence classes for direct node id 17 "foo.arg0": pointer 12, location 0
Equivalence classes for indirect node id 18 "x": pointer 9, location 5
Equivalence classes for indirect node id 19 "p": pointer 17, location 6
Equivalence classes for indirect node id 20 "b": pointer 18, location 7
Equivalence classes for direct node id 21 "_5": pointer 16, location 0
Equivalence classes for direct node id 22 "abort": pointer 0, location 0
Equivalence classes for indirect node id 23 "a": pointer 19, location 8
Equivalence classes for direct node id 24 "_4": pointer 8, location 0
Equivalence classes for direct node id 25 "derefaddrtmp": pointer 15, location 0
Equivalence classes for direct node id 26 "x.0_6": pointer 9, location 0
Equivalence classes for direct node id 27 "derefaddrtmp": pointer 20, location 0
Equivalence classes for direct node id 28 "_8": pointer 8, location 0
Equivalence classes for direct node id 29 "_9": pointer 16, location 0
STOREDANYTHING is a non-pointer variable, eliminating edges.
main is a non-pointer variable, eliminating edges.
main.varargs is a non-pointer variable, eliminating edges.
foo is a non-pointer variable, eliminating edges.
abort is a non-pointer variable, eliminating edges.
Rewriting constraints and unifying variables
Unifying foo.result to _5
Unifying derefaddrtmp to main.result
Unifying _8 to _4
Unifying _9 to _5
Uniting pointer but not location equivalent variables
Unifying x to x.0_6
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL p b a }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
main.clobber = { ESCAPED NONLOCAL x p b a }
main.use = { ESCAPED NONLOCAL x p b a }
main.result = { NULL }
main.varargs = { }
foo.clobber = { ESCAPED NONLOCAL p b a }
foo.use = { ESCAPED NONLOCAL x p b a }
foo.result = { NULL ESCAPED NONLOCAL } same as _5
foo.arg0 = { p }
x = { ESCAPED NONLOCAL p } same as x.0_6
p = { ESCAPED NONLOCAL b a }
b = { NULL ESCAPED NONLOCAL }
_5 = { NULL ESCAPED NONLOCAL }
abort = { }
a = { NULL ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL b a }
derefaddrtmp = { NULL } same as main.result
x.0_6 = { ESCAPED NONLOCAL p }
derefaddrtmp = { a }
_8 = { ESCAPED NONLOCAL b a } same as _4
_9 = { NULL ESCAPED NONLOCAL } same as _5
main ()
{
  int * p;
  int b;
  int _5;

  <bb 2>:
  p = &b;
  x = &p;
  _5 = foo (&p);
  if (_5 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  b ={v} {CLOBBER};
  p ={v} {CLOBBER};
  return 0;

}


foo (int * * q)
{
  int a;
  int * _4;
  int * * x.0_6;
  int * _8;
  int _9;

  <bb 2>:
  a = 1;
  _4 = *q_3(D);
  *_4 = 0;
  x.0_6 = x;
  *x.0_6 = &a;
  _8 = *q_3(D);
  _9 = *_8;
  a ={v} {CLOBBER};
  return _9;

}


