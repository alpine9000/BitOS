Symbol table:

abort/2 (abort) @0x142603640
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  First run: 0
  Function flags:
  Called by: main/1 
  Calls: 
main/1 (main) @0x1426034b0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  First run: 0
  Function flags: body only_called_at_startup executed_once only_called_at_startup
  Called by: 
  Calls: abort/2 foo/0 (1.00 per call) 
foo/0 (foo) @0x142603320
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  First run: 0
  Function flags: body local nonfreeing_fn executed_once
  Called by: main/1 (1.00 per call) 
  Calls: 


;; Function main (main, funcdef_no=1, decl_uid=1463, cgraph_uid=1, symbol_order=1) (executed once)

Modification phase of node main/1
main ()
{
  void * p;
  struct X c;
  struct X a;
  void * _6;

  <bb 2>:
  a.p = &c;
  p_4 = foo (&a, &a);
  MEM[(struct X *)p_4].p = 0B;
  _6 = a.p;
  if (_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  a ={v} {CLOBBER};
  c ={v} {CLOBBER};
  return 0;

}



;; Function foo (foo, funcdef_no=0, decl_uid=1458, cgraph_uid=0, symbol_order=0) (executed once)

Modification phase of node foo/0
  Adjusting alignment of param 0 to 4, misalignment to 0
  Adjusting alignment of param 1 to 4, misalignment to 0
foo (struct X * q, void * p)
{
  struct X b;
  void * _6;

  <bb 2>:
  b.p = p_2(D);
  *q_4(D) = b;
  _6 = q_4(D)->p;
  b ={v} {CLOBBER};
  return _6;

}


Generating constraints for global initializers

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING

Generating constraints for main (main)

a.32+32 = &c.0+32
foo.arg0 = &a.0+32
foo.arg1 = &a.0+32
p_4 = foo.result
main.use = &a.0+32
main.use = &a.0+32
main.clobber = foo.clobber
main.use = foo.use
derefaddrtmp = &NULL
*p_4 + 32 = derefaddrtmp
main.clobber = p_4 + 32
_6 = a.32+32
main.clobber = ESCAPED
main.use = ESCAPED
main.result = &NULL

Generating constraints for foo (foo)

b.32+32 = foo.arg1
*foo.arg0 + UNKNOWN = b.0+32
*foo.arg0 + UNKNOWN = b.32+32
foo.clobber = foo.arg0
_6 = *foo.arg0 + 32
foo.use = foo.arg0 + 32
foo.result = _6


Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Found location equivalence for node NONLOCAL
Equivalence classes for indirect node id 1 "NULL": pointer 1, location 1
Equivalence classes for indirect node id 2 "ANYTHING": pointer 2, location 2
Equivalence classes for indirect node id 3 "STRING": pointer 3, location 0
Equivalence classes for indirect node id 4 "ESCAPED": pointer 6, location 3
Equivalence classes for indirect node id 5 "NONLOCAL": pointer 4, location 3
Equivalence classes for direct node id 6 "STOREDANYTHING": pointer 0, location 0
Equivalence classes for indirect node id 7 "INTEGER": pointer 7, location 0
Equivalence classes for direct node id 8 "main": pointer 0, location 0
Equivalence classes for indirect node id 9 "main.clobber": pointer 9, location 0
Equivalence classes for direct node id 10 "main.use": pointer 11, location 0
Equivalence classes for direct node id 11 "main.result": pointer 12, location 0
Equivalence classes for direct node id 12 "main.varargs": pointer 0, location 0
Equivalence classes for direct node id 13 "foo": pointer 0, location 0
Equivalence classes for direct node id 14 "foo.clobber": pointer 8, location 0
Equivalence classes for indirect node id 15 "foo.use": pointer 10, location 0
Equivalence classes for direct node id 16 "foo.result": pointer 13, location 0
Equivalence classes for direct node id 17 "foo.arg0": pointer 8, location 0
Equivalence classes for direct node id 18 "foo.arg1": pointer 8, location 0
Equivalence classes for indirect node id 19 "a.0+32": pointer 14, location 4
Equivalence classes for indirect node id 20 "a.32+32": pointer 15, location 0
Equivalence classes for indirect node id 21 "c.0+32": pointer 16, location 5
Equivalence classes for indirect node id 22 "c.32+32": pointer 17, location 0
Equivalence classes for direct node id 23 "p_4": pointer 13, location 0
Equivalence classes for direct node id 24 "derefaddrtmp": pointer 12, location 0
Equivalence classes for direct node id 25 "_6": pointer 15, location 0
Equivalence classes for direct node id 26 "abort": pointer 0, location 0
Equivalence classes for direct node id 27 "b.0+32": pointer 0, location 0
Equivalence classes for direct node id 28 "b.32+32": pointer 8, location 0
Equivalence classes for indirect node id 29 "_6": pointer 13, location 0
STOREDANYTHING is a non-pointer variable, eliminating edges.
main is a non-pointer variable, eliminating edges.
main.varargs is a non-pointer variable, eliminating edges.
foo is a non-pointer variable, eliminating edges.
abort is a non-pointer variable, eliminating edges.
b.0+32 is a non-pointer variable, eliminating edges.
Rewriting constraints and unifying variables
Unifying foo.arg1 to foo.arg0
Unifying foo.result to p_4
Unifying foo.clobber to foo.arg0
Unifying _6 to a.32+32
Unifying main.result to derefaddrtmp
Unifying b.32+32 to foo.arg0
b.0+32 is a non-pointer variable,ignoring constraint:*foo.arg0 + UNKNOWN = b.0+32
Unifying _6 to p_4
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
main.clobber = { NULL a.0+32 a.32+32 c.32+32 }
main.use = { a.0+32 a.32+32 }
main.result = { NULL } same as derefaddrtmp
main.varargs = { }
foo.clobber = { a.0+32 } same as foo.arg0
foo.use = { a.32+32 }
foo.result = { NULL a.0+32 c.0+32 } same as p_4
foo.arg0 = { a.0+32 }
foo.arg1 = { a.0+32 } same as foo.arg0
a.0+32 = { a.0+32 }
a.32+32 = { NULL a.0+32 c.0+32 }
c.0+32 = { }
c.32+32 = { NULL }
p_4 = { NULL a.0+32 c.0+32 }
derefaddrtmp = { NULL }
_6 = { NULL a.0+32 c.0+32 } same as a.32+32
abort = { }
b.0+32 = { }
b.32+32 = { a.0+32 } same as foo.arg0
_6 = { NULL a.0+32 c.0+32 } same as p_4
main ()
{
  void * p;
  struct X c;
  struct X a;
  void * _6;

  <bb 2>:
  a.p = &c;
  p_4 = foo (&a, &a);
  MEM[(struct X *)p_4].p = 0B;
  _6 = a.p;
  if (_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  a ={v} {CLOBBER};
  c ={v} {CLOBBER};
  return 0;

}


foo (struct X * q, void * p)
{
  struct X b;
  void * _6;

  <bb 2>:
  b.p = p_2(D);
  *q_4(D) = b;
  _6 = q_4(D)->p;
  b ={v} {CLOBBER};
  return _6;

}


