Symbol table:

__builtin_va_end/4 (__builtin_va_end) @0x142603960
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  First run: 0
  Function flags:
  Called by: foo/0 (1.00 per call) 
  Calls: 
__builtin_va_start/3 (__builtin_va_start) @0x1426037d0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  First run: 0
  Function flags:
  Called by: foo/0 (1.00 per call) 
  Calls: 
abort/2 (abort) @0x142603640
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  First run: 0
  Function flags:
  Called by: main/1 
  Calls: 
main/1 (main) @0x1426034b0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  First run: 0
  Function flags: body only_called_at_startup executed_once only_called_at_startup
  Called by: 
  Calls: abort/2 foo/0 (1.00 per call) 
foo/0 (foo) @0x142603320
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  First run: 0
  Function flags: body local executed_once
  Called by: main/1 (1.00 per call) 
  Calls: __builtin_va_end/4 (1.00 per call) __builtin_va_start/3 (1.00 per call) 


;; Function main (main, funcdef_no=1, decl_uid=1462, cgraph_uid=1, symbol_order=1) (executed once)

Modification phase of node main/1
main ()
{
  int i;
  int i.0_4;

  <bb 2>:
  i = 0;
  foo (0, &i);
  i.0_4 = i;
  if (i.0_4 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  i ={v} {CLOBBER};
  return 0;

}



;; Function foo (foo, funcdef_no=0, decl_uid=1456, cgraph_uid=0, symbol_order=0) (executed once)

Modification phase of node foo/0
foo (int i)
{
  int * p;
  struct va_list ap;
  void * * _1;
  void * _4;
  void * _5;
  void * _6;
  void * _7;
  void * _8;

  <bb 2>:
  __builtin_va_start (&ap, 0);
  _4 = ap.__va_next_o;
  _5 = _4 + 4;
  _6 = ap.__va_next_o_limit;
  if (_5 > _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:

  <bb 4>:
  # _1 = PHI <&ap.__va_next_o(2), &ap.__va_next_stack(3)>
  _7 = *_1;
  _8 = _7 + 4;
  *_1 = _8;
  p_10 = MEM[(int * *)_7];
  *p_10 = 1;
  __builtin_va_end (&ap);
  ap ={v} {CLOBBER};
  return;

}


Generating constraints for global initializers

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING

Generating constraints for main (main)

i = &NULL
foo.arg0 = &NULL
foo.varargs = &i
main.use = &i
main.clobber = foo.clobber
main.use = foo.use
i.0_4 = i
main.clobber = ESCAPED
main.use = ESCAPED
main.result = &NULL

Generating constraints for foo (foo)

ap.0+32 = &foo.varargs
CALLCLOBBERED = &ap.0+32
_4 = ap.0+32
_5 = _4 + 32
_6 = ap.32+32
_1 = &ap.0+32
_1 = &ap.128+32
_7 = *_1
foo.use = _1
_8 = _7 + 32
*_1 = _8
foo.clobber = _1
p_10 = *_7
foo.use = _7
derefaddrtmp = &NONLOCAL
*p_10 = derefaddrtmp
foo.clobber = p_10


Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Equivalence classes for indirect node id 1 "NULL": pointer 1, location 1
Equivalence classes for indirect node id 2 "ANYTHING": pointer 2, location 2
Equivalence classes for indirect node id 3 "STRING": pointer 3, location 0
Equivalence classes for indirect node id 4 "ESCAPED": pointer 6, location 3
Equivalence classes for indirect node id 5 "NONLOCAL": pointer 4, location 4
Equivalence classes for direct node id 6 "STOREDANYTHING": pointer 0, location 0
Equivalence classes for indirect node id 7 "INTEGER": pointer 7, location 0
Equivalence classes for direct node id 8 "main": pointer 0, location 0
Equivalence classes for direct node id 9 "main.clobber": pointer 11, location 0
Equivalence classes for direct node id 10 "main.use": pointer 15, location 0
Equivalence classes for direct node id 11 "main.result": pointer 16, location 0
Equivalence classes for direct node id 12 "main.varargs": pointer 0, location 0
Equivalence classes for direct node id 13 "foo": pointer 0, location 0
Equivalence classes for direct node id 14 "foo.clobber": pointer 10, location 0
Equivalence classes for direct node id 15 "foo.use": pointer 14, location 0
Equivalence classes for direct node id 16 "foo.result": pointer 0, location 0
Equivalence classes for direct node id 17 "foo.arg0": pointer 16, location 0
Equivalence classes for indirect node id 18 "foo.varargs": pointer 17, location 5
Equivalence classes for indirect node id 19 "i": pointer 18, location 6
Equivalence classes for direct node id 20 "i.0_4": pointer 18, location 0
Equivalence classes for direct node id 21 "abort": pointer 0, location 0
Equivalence classes for indirect node id 22 "ap.0+32": pointer 19, location 7
Equivalence classes for indirect node id 23 "ap.32+32": pointer 20, location 0
Equivalence classes for indirect node id 24 "ap.64+32": pointer 21, location 0
Equivalence classes for indirect node id 25 "ap.96+32": pointer 22, location 0
Equivalence classes for indirect node id 26 "ap.128+32": pointer 23, location 8
Equivalence classes for direct node id 27 "CALLUSED": pointer 0, location 0
Equivalence classes for direct node id 28 "CALLCLOBBERED": pointer 24, location 0
Equivalence classes for direct node id 29 "_4": pointer 19, location 0
Equivalence classes for indirect node id 30 "_5": pointer 25, location 0
Equivalence classes for direct node id 31 "_6": pointer 20, location 0
Equivalence classes for direct node id 32 "_1": pointer 8, location 0
Equivalence classes for direct node id 33 "_7": pointer 13, location 0
Equivalence classes for indirect node id 34 "_8": pointer 12, location 0
Equivalence classes for direct node id 35 "p_10": pointer 9, location 0
Equivalence classes for direct node id 36 "derefaddrtmp": pointer 26, location 0
STOREDANYTHING is a non-pointer variable, eliminating edges.
main is a non-pointer variable, eliminating edges.
main.varargs is a non-pointer variable, eliminating edges.
foo is a non-pointer variable, eliminating edges.
foo.result is a non-pointer variable, eliminating edges.
abort is a non-pointer variable, eliminating edges.
CALLUSED is a non-pointer variable, eliminating edges.
Rewriting constraints and unifying variables
Unifying main.result to foo.arg0
Unifying ap.32+32 to _6
Uniting pointer but not location equivalent variables
Unifying i to i.0_4
Unifying ap.0+32 to _4
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
main.clobber = { i ap.0+32 ap.128+32 }
main.use = { foo.varargs i ap.0+32 ap.128+32 }
main.result = { NULL } same as foo.arg0
main.varargs = { }
foo.clobber = { i ap.0+32 ap.128+32 }
foo.use = { foo.varargs ap.0+32 ap.128+32 }
foo.result = { }
foo.arg0 = { NULL }
foo.varargs = { i }
i = { NULL NONLOCAL } same as i.0_4
i.0_4 = { NULL NONLOCAL }
abort = { }
ap.0+32 = { foo.varargs } same as _4
ap.32+32 = { } same as _6
ap.64+32 = { }
ap.96+32 = { }
ap.128+32 = { foo.varargs }
CALLUSED = { }
CALLCLOBBERED = { ap.0+32 }
_4 = { foo.varargs }
_5 = { foo.varargs }
_6 = { }
_1 = { ap.0+32 ap.128+32 }
_7 = { foo.varargs }
_8 = { foo.varargs }
p_10 = { i }
derefaddrtmp = { NONLOCAL }
main ()
{
  int i;
  int i.0_4;

  <bb 2>:
  i = 0;
  foo (0, &i);
  i.0_4 = i;
  if (i.0_4 != 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  abort ();

  <bb 4>:
  i ={v} {CLOBBER};
  return 0;

}


foo (int i)
{
  int * p;
  struct va_list ap;
  void * * _1;
  void * _4;
  void * _5;
  void * _6;
  void * _7;
  void * _8;

  <bb 2>:
  __builtin_va_start (&ap, 0);
  _4 = ap.__va_next_o;
  _5 = _4 + 4;
  _6 = ap.__va_next_o_limit;
  if (_5 > _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:

  <bb 4>:
  # _1 = PHI <&ap.__va_next_o(2), &ap.__va_next_stack(3)>
  _7 = *_1;
  _8 = _7 + 4;
  *_1 = _8;
  p_10 = MEM[(int * *)_7];
  *p_10 = 1;
  __builtin_va_end (&ap);
  ap ={v} {CLOBBER};
  return;

}


